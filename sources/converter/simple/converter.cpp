/* Convert trace generated by the KEDR into simple human-readable messages */

#include <kedr/kedr_trace_reader/kedr_trace_reader.h>

#include <kedr/object_types.h> /* Enumerations describing events */

#include <iostream>
#include <stdexcept>

#include <iomanip>

#include <unistd.h> /* sleep */

/* Wrapper around addresses for pretty printing */
struct Addr64
{
    Addr64(uint64_t addr) : addr(addr) {}
    
    uint64_t addr;
};

std::ostream& operator<<(std::ostream& os, const struct Addr64& addr)
{
    std::ios_base::fmtflags oldFlags = os.flags();
    char oldFill = os.fill();
    int oldWidth = os.width();
    
    os.fill('0');
    os << std::hex << std::setw(16) << std::right << addr.addr;
    
    os.flags(oldFlags);
    os.fill(oldFill);
    os.width(oldWidth);
    
    return os;
}

/* Helpers for search typed variables */
static const CTFVarInt& findInt(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find integer variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isInt())
    {
        std::cerr << "Variable with name '" << name << "' is not integer.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarInt*>(var);
}

static const CTFVarEnum& findEnum(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find enumeration variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isEnum())
    {
        std::cerr << "Variable with name '" << name << "' is not enumeration.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarEnum*>(var);
}

static const CTFVarArray& findArray(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find array-like variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isArray())
    {
        std::cerr << "Variable with name '" << name << "' is not array-like.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarArray*>(var);
}

class EventPrinterType;
/* Output information about event in human-readable form */
class EventPrinter
{
public:
    EventPrinter(const KEDRTraceReader& traceReader);
    ~EventPrinter(void);
    
    void print(CTFReader::Event& event, std::ostream& os) const;

    /* Helper for printers for concrete type of events */
    void printHeader(CTFReader::Event& event, std::ostream& os) const;
    
    const KEDRTraceReader& getTraceReader(void) const
        {return traceReader;}
private:
    const KEDRTraceReader& traceReader;
    /* Printers for each index of event type enumeration. */
    std::vector<EventPrinterType*> typePrinters;
    
    const CTFVarEnum* eventTypeVar;
    /* Variable used in header printing */
    const CTFVarInt* cpuVar;
    const CTFVarInt* timestampVar;
    const CTFVarInt* tidVar;
};


/* Abstract class which process event of concrete type */
class EventPrinterType
{
public:
    virtual ~EventPrinterType() {}
    
    virtual void print(CTFReader::Event& event, std::ostream& os) = 0;
};

/* Concrete specializations of the class */

/* Print event in one line. This approach is used for the most event types. */
class EventPrinterOneLine : public EventPrinterType
{
public:
    EventPrinterOneLine(const EventPrinter& eventPrinter)
        : eventPrinter(eventPrinter) {}
    
    void print(CTFReader::Event& event, std::ostream& os);
protected:
    /* 
     * Print only type-specific event fields.
     * 
     * Following stream properties will be restored automatically
     * after function call:
     * 
     * - format flags
     * - width
     * - fill character
     */
    virtual void printEventFields(CTFReader::Event& event, std::ostream& os) = 0;
private:
    const EventPrinter& eventPrinter;
};

void EventPrinterOneLine::print(CTFReader::Event& event, std::ostream& os)
{
    eventPrinter.printHeader(event, os);
    
    std::ios_base::fmtflags oldFlags = os.flags();
    char oldFill = os.fill();
    int oldWidth = os.width();
    
    printEventFields(event, os);
    
    os.flags(oldFlags);
    os.fill(oldFill);
    os.width(oldWidth);
    
    os << std::endl;
}

/* Unknown event type (for intermediate implementation). */
class EventPrinterUnknown: public EventPrinterOneLine
{
public:
    EventPrinterUnknown(const EventPrinter& eventPrinter)
        : EventPrinterOneLine(eventPrinter)
    {
        eventTypeVar = &findEnum(eventPrinter.getTraceReader(),
            "stream.event.header.type");
    }
protected:
    void printEventFields(CTFReader::Event& event, std::ostream& os)
    {
        std::string type = eventTypeVar->getEnum(event);
        if(type == "") type = "(unknown)";
        
        os << "Unknown event type: " << type;
    }
private:
    const CTFVarEnum* eventTypeVar;
};

/* Function entry */
class EventPrinterFEntry: public EventPrinterOneLine
{
public:
    EventPrinterFEntry(const EventPrinter& eventPrinter)
        : EventPrinterOneLine(eventPrinter)
    {
        funcAddrVar = &findInt(eventPrinter.getTraceReader(),
            "event.fields.fentry.func");
    }
protected:
    void printEventFields(CTFReader::Event& event, std::ostream& os)
    {
        uint64_t funcAddr = funcAddrVar->getUInt64(event);
        
        os << "Enter to function " << Addr64(funcAddr);
    }
private:
    const CTFVarInt* funcAddrVar;
};

/* Function exit */
class EventPrinterFExit: public EventPrinterOneLine
{
public:
    EventPrinterFExit(const EventPrinter& eventPrinter)
        : EventPrinterOneLine(eventPrinter)
    {
        funcAddrVar = &findInt(eventPrinter.getTraceReader(),
            "event.fields.fexit.func");
    }
protected:
    void printEventFields(CTFReader::Event& event, std::ostream& os)
    {
        uint64_t funcAddr = funcAddrVar->getUInt64(event);
        
        os << "Exit from function " << Addr64(funcAddr);
    }
private:
    const CTFVarInt* funcAddrVar;
};

/* Memory accesses */
class EventPrinterMA: public EventPrinterType
{
public:
    EventPrinterMA(const EventPrinter& eventPrinter);
    
    void print(CTFReader::Event& event, std::ostream& os);
private:
    const EventPrinter& eventPrinter;
    
    const CTFVarArray* accessesVar;
    
    const CTFVarInt* pcVar;
    const CTFVarInt* addrVar;
    const CTFVarInt* sizeVar;
    const CTFVarInt* accessTypeVar;
};

EventPrinterMA::EventPrinterMA(const EventPrinter& eventPrinter)
    : eventPrinter(eventPrinter)
{
    const CTFReader& reader = eventPrinter.getTraceReader();
    
    accessesVar = &findArray(reader, "event.fields.ma");
    
    pcVar = &findInt(reader, "event.fields.ma[].pc");
    addrVar = &findInt(reader, "event.fields.ma[].addr");
    sizeVar = &findInt(reader, "event.fields.ma[].size");
    accessTypeVar = &findInt(reader, "event.fields.ma[].access_type");
}

void EventPrinterMA::print(CTFReader::Event& event, std::ostream& os)
{
    //debug
    int i = 0;
    for(CTFVarArray::ElemIterator iter(*accessesVar, event);
        iter;
        ++iter)
    {
        eventPrinter.printHeader(event, os);
        
        uint64_t pc = pcVar->getUInt64(*iter);
        uint64_t addr = addrVar->getUInt64(*iter);
        uint64_t size = sizeVar->getUInt64(*iter);
        int accessType = accessTypeVar->getInt32(*iter);
        
        os << "At " << Addr64(pc) << "\t";
        switch(accessType)
        {
        case KEDR_ET_MREAD:
            os << "Read " << size << " bytes from " << Addr64(addr);
        break;
        case KEDR_ET_MWRITE:
            os << "Write " << size << " bytes to " << Addr64(addr);
        break;
        case KEDR_ET_MUPDATE:
            os << "Update " << size << " bytes at " << Addr64(addr);
        break;
        default:
            os << "Unknown memory access operation";
        }
        
        os << "\n";
        
        //debug
        if((++i % 10) == 0) sleep(1);
    }
}

EventPrinter::EventPrinter(const KEDRTraceReader& traceReader)
    : traceReader(traceReader)
{
    cpuVar = &findInt(traceReader, "trace.packet.header.cpu");
    timestampVar = &findInt(traceReader, "stream.event.context.timestamp");
    tidVar = &findInt(traceReader, "stream.event.context.tid");
    
    eventTypeVar = &findEnum(traceReader, "stream.event.header.type");
    
    const CTFTypeEnum* eventTypeEnum = eventTypeVar->getType();
    int nValues = eventTypeEnum->getNValues();
    
    typePrinters.reserve(nValues);
    
    for(int i = 0; i < nValues; i++)
    {
        const std::string& eventType = eventTypeEnum->valueToStr(i);

        std::cerr << "Possible event type: " << eventType << std::endl;

        EventPrinterType* eventPrinterType;
        if(eventType == "fentry")
            eventPrinterType = new EventPrinterFEntry(*this);
        else if(eventType == "fexit")
            eventPrinterType = new EventPrinterFExit(*this);
        else if(eventType == "ma")
            eventPrinterType = new EventPrinterMA(*this);
        //TODO: other event types
        else
            eventPrinterType = new EventPrinterUnknown(*this);
        
        typePrinters.push_back(eventPrinterType);
    }
}

EventPrinter::~EventPrinter(void)
{
    for(int i = 0; i < (int)typePrinters.size(); i++)
        delete typePrinters[i];
}

void EventPrinter::print(CTFReader::Event& event, std::ostream& os) const
{
    int index = eventTypeVar->getValue(event);
    
    typePrinters[index]->print(event, os);
}

void EventPrinter::printHeader(CTFReader::Event& event, std::ostream& os) const
{
    std::ios_base::fmtflags oldFlags = os.flags();
    char oldFill = os.fill();
    int oldWidth = os.width();
    
    int cpu = cpuVar->getInt32(event);
    uint64_t timestamp = timestampVar->getUInt64(event);
    uint64_t seconds = timestamp / 1000000000L;
    uint64_t ns = timestamp % 1000000000L;
    
    uint64_t tid = tidVar->getUInt64(event);
    
    os << Addr64(tid);
    
    os << "\t";
    
    os << "[" << std::dec << std::setw(3) << cpu << "]";
    
    os << "\t";

    os.fill('0');    
    os << std::dec << seconds  << "." << std::setw(6) << ns/1000;
    
    os << ":\t";
    
    os.flags(oldFlags);
    os.fill(oldFill);
    os.width(oldWidth);
}

int main(int argc, char** argv)
{
    if(argc != 2)
    {
        std::cerr << "Usage: kedr_simple_converter <directory-with-trace>";
        return -1;
    }
    
    KEDRTraceReader traceReader(argv[1]);
    
    EventPrinter eventPrinter(traceReader);
    
    int i = 0;
    for(KEDRTraceReader::EventIterator iter(traceReader); iter; ++iter)
    {
        //TODO: output event content
        eventPrinter.print(*iter, std::cout);
        //debug
        if((++i % 10) == 0) sleep(1);

    }
    
    return 0;
}