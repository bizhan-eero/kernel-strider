/* 
 * Convert trace generated by the KEDR into format which may be
 * processed by Thread Sanitizer.
 */

#include <kedr/kedr_trace_reader/kedr_trace_reader.h>

#include <kedr/object_types.h> /* Enumerations describing events */

#include <iostream>
#include <stdexcept>

#include <iomanip>

#include <vector>
#include <map>

/* Wrapper around addresses for template extracting and pretty printing */
template<class T>
struct Addr;

template<>
struct Addr<uint32_t>
{
    Addr(const CTFVarInt& var, CTFContext& context):
        addr(var.getUInt32(context)) {}
    
    bool operator<(const Addr<uint32_t>& addr) const {return this->addr < addr.addr;}
    
    uint32_t addr;
};

template<>
struct Addr<uint64_t>
{
    Addr(const CTFVarInt& var, CTFContext& context):
        addr(var.getUInt64(context))
    {
        //debug
        if(!var.isExist(context))
        {
            std::cerr << "Variable " << var.name() << " doesnt't exist "
                "in given context.\n";
            throw std::logic_error("Read unexistent variable.\n");
        }
    }
    
    uint64_t addr;
};


template<class T>
std::ostream& operator<<(std::ostream& os, const struct Addr<T>& addr)
{
    std::ios_base::fmtflags oldFlags = os.flags();
    
    os << std::hex << addr.addr;
    
    os.flags(oldFlags);
    
    return os;
}


/* Wrapper around addresses for template extracting and pretty printing */
template<class T>
struct Size;

template<>
struct Size<uint32_t>
{
    Size(const CTFVarInt& var, CTFContext& context):
        size(var.getUInt32(context))
    {
        //debug
        if(!var.isExist(context))
        {
            std::cerr << "Variable " << var.name() << " doesnt't exist "
                "in given context.\n";
            throw std::logic_error("Read unexistent variable.\n");
        }
    }

    
    uint32_t size;
};

template<>
struct Size<uint64_t>
{
    Size(const CTFVarInt& var, CTFContext& context):
        size(var.getUInt64(context)) {}
    
    uint64_t size;
};


template<class T>
std::ostream& operator<<(std::ostream& os, const struct Size<T>& size)
{
    std::ios_base::fmtflags oldFlags = os.flags();
    
    os << std::hex << size.size;
    
    os.flags(oldFlags);
    
    return os;
}

/* Wrapper around thread identificator for pretty printing */
struct Tid
{
    Tid(int tid): tid(tid){}
    
    Tid& operator=(const Tid& tid) {this->tid = tid.tid; return *this;}
    Tid& operator=(int tid) {this->tid = tid; return *this;}
    
    bool operator==(int tid) {return this->tid == tid;}
    bool operator!=(int tid) {return this->tid != tid;}
    
    int tid;
};

std::ostream& operator<<(std::ostream& os, const struct Tid& tid)
{
    std::ios_base::fmtflags oldFlags = os.flags();
    
    os << std::hex << tid.tid;
    
    os.flags(oldFlags);
    
    return os;
}


/* Helpers for search typed variables */
static const CTFVarInt& findInt(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find integer variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isInt())
    {
        std::cerr << "Variable with name '" << name << "' is not integer.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarInt*>(var);
}

static const CTFVarEnum& findEnum(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find enumeration variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isEnum())
    {
        std::cerr << "Variable with name '" << name << "' is not enumeration.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarEnum*>(var);
}

static const CTFVarArray& findArray(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find array-like variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isArray())
    {
        std::cerr << "Variable with name '" << name << "' is not array-like.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarArray*>(var);
}

class TsanEventBuilder;

/* 
 * Build trace for tsan in needed format.
 * 
 * 'T' means address integer type and may be uint32_t or uint64_t.
 */
template<class T>
class TsanTraceBuilder
{
public:
    TsanTraceBuilder(const KEDRTraceReader& traceReader);
    ~TsanTraceBuilder(void);
    /* Build trace into given stream */
    void build(std::ostream& os);

    /* Helpers for use in event builders */
    void registerThreadStart(Tid tid) const
        {*os << "THR_START " << tid << " 0 0 0\n";}
    void registerRead(Tid tid, Addr<T> pc, Addr<T> addr, Size<T> size) const
        {*os << "READ " << tid << " " << pc << " " << addr << " " << size << "\n";}
    void registerWrite(Tid tid, Addr<T> pc, Addr<T> addr, Size<T> size) const
        {*os << "WRITE " << tid << " " << pc << " " << addr << " " << size << "\n";}
    void registerSignal(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "SIGNAL " << tid << " " << pc << " " << obj << " 0\n";}
    void registerWait(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "WAIT " << tid << " " << pc << " " << obj << " 0\n";}
    void registerFunctionCall(Tid tid, Addr<T> pc, Addr<T>) const
        {*os << "RTN_CALL " << tid << " " << pc << " 0 0\n";}
    void registerFunctionExit(Tid tid, Addr<T>, Addr<T>) const
        {*os << "RTN_EXIT " << tid << " 0 0 0\n";}
    void registerLock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "WRITER_LOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void registerRLock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "READER_LOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void registerUnlock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "UNLOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void registerAlloc(Tid tid, Addr<T> pc, Addr<T> pointer, Size<T> size) const
        {*os << "MALLOC " << tid << " " << pc << " " << pointer << " " << size << "\n";}
    void registerFree(Tid tid, Addr<T> pc, Addr<T> pointer) const
        {*os << "FREE " << tid << " " << pc << " " << pointer << " 0\n";}
    void registerBlock(Tid tid, Addr<T> pc) const
        {*os << "SBLOCK_ENTER " << tid << " " << pc << " 0 0\n";}

    const KEDRTraceReader& getTraceReader(void) const
        {return traceReader;}
private:
    const KEDRTraceReader& traceReader;
    /* Builder for each index of event type enumeration. */
    std::vector<TsanEventBuilder*> eventBuilders;
    /* Map of registered threads */
    std::map<Addr<T>, int> threads;
    /* first unused identificator for tid*/
    int firstUnusedTid;
    /* 
     * Return integer identificator of thread for given address.
     * If thread is not registered, return -1.
     */
    Tid getTid(Addr<T> taddr) const;
    /*
     * Register new integer identificator to thread of given address.
     */
    Tid newTid(Addr<T> taddr);
    
    void setupEventBuilders(void);
    
    const CTFVarEnum& eventTypeVar;
    /* Variable used in header printing */
    const CTFVarInt& tidVar;
    /* Output information about one event */
    void buildEvent(CTFReader::Event& event);
    
    std::ostream* os;
};

template<class T>
TsanTraceBuilder<T>::TsanTraceBuilder(const KEDRTraceReader& traceReader)
    : traceReader(traceReader),
    eventTypeVar(findEnum(traceReader, "stream.event.header.type")),
    tidVar(findInt(traceReader, "stream.event.context.tid"))
{
    setupEventBuilders();
}

/* Abstract class which process event of concrete type */
class TsanEventBuilder
{
public:
    virtual ~TsanEventBuilder() {}
    
    virtual void build(CTFReader::Event& event, Tid tid) = 0;
};

template<class T>
TsanTraceBuilder<T>::~TsanTraceBuilder(void)
{
    for(int i = 0; i < (int)eventBuilders.size(); i++)
        delete eventBuilders[i];
}

template<class T>
void TsanTraceBuilder<T>::build(std::ostream& os)
{
    this->os = &os;
    
    threads.clear();
    firstUnusedTid = 0;
    
    for(KEDRTraceReader::EventIterator iter(traceReader);
        iter;
        ++iter)
    {
        Addr<T> tidAddr(tidVar, *iter);
        Tid tid = getTid(tidAddr);
        if(tid == -1)
        {
            tid = newTid(tidAddr);
            registerThreadStart(tid);
        }
       
        int index = eventTypeVar.getValue(*iter);
        eventBuilders[index]->build(*iter, tid);
    }
    
    threads.clear();
    this->os = NULL;
}

template<class T>
Tid TsanTraceBuilder<T>::getTid(Addr<T> addr) const
{
    typename std::map<Addr<T>, int>::const_iterator iter = threads.find(addr);
    return (iter != threads.end()) ? iter->second : -1;
}

template<class T>
Tid TsanTraceBuilder<T>::newTid(Addr<T> addr)
{
    threads.insert(std::make_pair(addr, firstUnusedTid));
    return firstUnusedTid++;
}

/* Concrete specializations of the class */

/* Ignore event(event doesn't affect on Tsan)*/
class TsanEventBuilderIgnore: public TsanEventBuilder
{
public:
    void build(CTFReader::Event&, Tid) {}
};


/* Unknown event type (for intermediate implementation). */
template<class T>
class TsanEventBuilderUnknown: public TsanEventBuilder
{
public:
    TsanEventBuilderUnknown(const TsanTraceBuilder<T>& eventBuilder):
        eventTypeVar(findEnum(eventBuilder.getTraceReader(),
            "stream.event.header.type")) {}
    
    void build(CTFReader::Event& event, Tid)
    {
        std::string typeStr = eventTypeVar.getEnum(event);
        if(typeStr == "") typeStr = "(undefined)";
        
        std::cerr << "Unknown event type: '" << typeStr << "'\n";
    }
private:
    const CTFVarEnum& eventTypeVar;
};

/* Function entry/exit are ignored */

/* Function call pre */
template<class T>
class TsanEventBuilderFunctionCallPre: public TsanEventBuilder
{
public:
    TsanEventBuilderFunctionCallPre(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.fcpre.pc")),
        funcAddrVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.fcpre.func"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        traceBuilder.registerFunctionCall(tid,
            Addr<T>(pcVar, event), Addr<T>(funcAddrVar, event));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& funcAddrVar;
};

/* Function call post */
template<class T>
class TsanEventBuilderFunctionCallPost: public TsanEventBuilder
{
public:
    TsanEventBuilderFunctionCallPost(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.fcpost.pc")),
        funcAddrVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.fcpost.func"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        traceBuilder.registerFunctionExit(tid,
            Addr<T>(pcVar, event), Addr<T>(funcAddrVar, event));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& funcAddrVar;
};

/* Memory accesses */
template<class T>
class TsanEventBuilderMA: public TsanEventBuilder
{
public:
    TsanEventBuilderMA(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        accessesVar(findArray(traceBuilder.getTraceReader(), "event.fields.ma")),
        pcVar(findInt(traceBuilder.getTraceReader(), "event.fields.ma[].pc")),
        addrVar(findInt(traceBuilder.getTraceReader(), "event.fields.ma[].addr")),
        sizeVar(findInt(traceBuilder.getTraceReader(), "event.fields.ma[].size")),
        accessTypeVar(findInt(traceBuilder.getTraceReader(), "event.fields.ma[].access_type"))
        {}
    
    void build(CTFReader::Event& event, Tid tid)
    {
        bool isFirst = true;
        for(CTFVarArray::ElemIterator iter(accessesVar, event);
            iter;
            ++iter)
        {
            if(isFirst)
            {
                traceBuilder.registerBlock(tid, Addr<T>(pcVar, *iter));
                isFirst = false;
            }
            buildOne(*iter, tid);
        }
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;

    const CTFVarArray& accessesVar;
    
    const CTFVarInt& pcVar;
    const CTFVarInt& addrVar;
    const CTFVarInt& sizeVar;
    const CTFVarInt& accessTypeVar;
    
    void buildOne(CTFContext& subevent, Tid tid)
    {
        int accessType = accessTypeVar.getInt32(subevent);
        Addr<T> pc(pcVar, subevent);
        Addr<T> addr(addrVar, subevent);
        Size<T> size(sizeVar, subevent);
        switch((enum kedr_memory_event_type)accessType)
        {
        case KEDR_ET_MREAD:
            traceBuilder.registerRead(tid, pc, addr, size);
        break;
        case KEDR_ET_MWRITE:
        case KEDR_ET_MUPDATE:
            traceBuilder.registerWrite(tid, pc, addr, size);
        break;
        default:
            std::cerr << "Unknown memory access operation.\n";
        }
    }
};

/* Locked operations are ignored */

/* IO operations */
template<class T>
class TsanEventBuilderIOMA: public TsanEventBuilder
{
public:
    TsanEventBuilderIOMA(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.ioma.pc")),
        addrVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.ioma.addr")),
        sizeVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.ioma.size")),
        accessTypeVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.ioma.access_type"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        int accessType = accessTypeVar.getUInt32(event);
        Addr<T> pc(pcVar, event);
        Addr<T> addr(addrVar, event);
        Size<T> size(sizeVar, event);
        
        switch((enum kedr_memory_event_type)accessType)
        {
        case KEDR_ET_MREAD:
            traceBuilder.registerRead(tid, pc, addr, size);
        break;
        case KEDR_ET_MWRITE:
        case KEDR_ET_MUPDATE:
            traceBuilder.registerWrite(tid, pc, addr, size);
        break;
        default:
            std::cerr << "Unknown memory access operation.\n";
        }
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& addrVar;
    const CTFVarInt& sizeVar;
    const CTFVarInt& accessTypeVar;
};

/* Barrier operations are ignored */

/* Alloc */
template<class T>
class TsanEventBuilderAlloc: public TsanEventBuilder
{
public:
    TsanEventBuilderAlloc(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.alloc.pc")),
        pointerVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.alloc.pointer")),
        sizeVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.alloc.size"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        Addr<T> pc(pcVar, event);
        Addr<T> pointer(pointerVar, event);
        Size<T> size(sizeVar, event);
        
        traceBuilder.registerAlloc(tid, pc, pointer, size);
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& pointerVar;
    const CTFVarInt& sizeVar;
};


/* Free */
template<class T>
class TsanEventBuilderFree: public TsanEventBuilder
{
public:
    TsanEventBuilderFree(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.free.pc")),
        pointerVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.free.pointer"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        Addr<T> pc(pcVar, event);
        Addr<T> pointer(pointerVar, event);
        
        traceBuilder.registerFree(tid, pc, pointer);
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& pointerVar;
};

/* Lock */
template<class T>
class TsanEventBuilderLock: public TsanEventBuilder
{
public:
    TsanEventBuilderLock(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.lock.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.lock.object"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        traceBuilder.registerLock(tid, Addr<T>(pcVar, event),
            Addr<T>(objectVar, event));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};

/* Unlock */
template<class T>
class TsanEventBuilderUnlock: public TsanEventBuilder
{
public:
    TsanEventBuilderUnlock(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.unlock.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.unlock.object"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        traceBuilder.registerUnlock(tid, Addr<T>(pcVar, event),
            Addr<T>(objectVar, event));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};


/* Read lock */
template<class T>
class TsanEventBuilderRLock: public TsanEventBuilder
{
public:
    TsanEventBuilderRLock(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.rlock.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.rlock.object"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        traceBuilder.registerRLock(tid, Addr<T>(pcVar, event),
            Addr<T>(objectVar, event));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};

/* Read unlock */
template<class T>
class TsanEventBuilderRUnlock: public TsanEventBuilder
{
public:
    TsanEventBuilderRUnlock(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.runlock.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.runlock.object"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        traceBuilder.registerUnlock(tid, Addr<T>(pcVar, event),
            Addr<T>(objectVar, event));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};

/* Signal */
template<class T>
class TsanEventBuilderSignal: public TsanEventBuilder
{
public:
    TsanEventBuilderSignal(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.signal.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.signal.object"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        traceBuilder.registerSignal(tid, Addr<T>(pcVar, event),
            Addr<T>(objectVar, event));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};

/* Wait */
template<class T>
class TsanEventBuilderWait: public TsanEventBuilder
{
public:
    TsanEventBuilderWait(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.wait.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.wait.object"))
        {}

    void build(CTFReader::Event& event, Tid tid)
    {
        traceBuilder.registerWait(tid, Addr<T>(pcVar, event),
            Addr<T>(objectVar, event));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};


/* Thread create/join are ignored */

template<class T>
void TsanTraceBuilder<T>::setupEventBuilders(void)
{
    const CTFTypeEnum* eventTypeEnum = eventTypeVar.getType();
    int nValues = eventTypeEnum->getNValues();
    
    eventBuilders.reserve(nValues);
    
    for(int i = 0; i < nValues; i++)
    {
        const std::string& eventType = eventTypeEnum->valueToStr(i);

        TsanEventBuilder* eventBuilder;
        if(eventType == "fentry")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "fexit")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "fcpre")
            eventBuilder = new TsanEventBuilderFunctionCallPre<T>(*this);
        else if(eventType == "fcpost")
            eventBuilder = new TsanEventBuilderFunctionCallPost<T>(*this);
        else if(eventType == "ma")
            eventBuilder = new TsanEventBuilderMA<T>(*this);
        else if(eventType == "lma_update")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "lma_read")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "lma_write")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "ioma")
            eventBuilder = new TsanEventBuilderIOMA<T>(*this);
        else if(eventType == "mwb")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "mrb")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "mfb")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "alloc")
            eventBuilder = new TsanEventBuilderAlloc<T>(*this);
        else if(eventType == "free")
            eventBuilder = new TsanEventBuilderFree<T>(*this);
        else if(eventType == "lock")
            eventBuilder = new TsanEventBuilderLock<T>(*this);
        else if(eventType == "unlock")
            eventBuilder = new TsanEventBuilderUnlock<T>(*this);
        else if(eventType == "rlock")
            eventBuilder = new TsanEventBuilderRLock<T>(*this);
        else if(eventType == "runlock")
            eventBuilder = new TsanEventBuilderRUnlock<T>(*this);
        else if(eventType == "signal")
            eventBuilder = new TsanEventBuilderSignal<T>(*this);
        else if(eventType == "wait")
            eventBuilder = new TsanEventBuilderWait<T>(*this);
        else if(eventType == "tcreate")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "tjoin")
            eventBuilder = new TsanEventBuilderIgnore();
        else
            eventBuilder = new TsanEventBuilderUnknown<T>(*this);
        
        eventBuilders.push_back(eventBuilder);
    }
}



int main(int argc, char** argv)
{
    if(argc != 2)
    {
        std::cerr << "Usage: kedr_simple_converter <directory-with-trace>";
        return -1;
    }
    
    KEDRTraceReader traceReader(argv[1]);
    
    const std::string* pointer_bits = traceReader.findParameter(
        "trace.pointer_bits");
    if(pointer_bits == NULL)
    {
        std::cerr << "Trace should have parameter 'trace.pointer_bits' "
            "defined, but it haven't\n";
        return 1;
    }
    else if(*pointer_bits == "32")
    {
        TsanTraceBuilder<uint32_t> traceBuilder(traceReader);
        traceBuilder.build(std::cout);
    }
    else if(*pointer_bits == "64")
    {
        TsanTraceBuilder<uint32_t> traceBuilder(traceReader);
        traceBuilder.build(std::cout);
    }
    else
    {
        std::cerr << "Unknown value of 'trace.pointer_bits' parameter: "
            << *pointer_bits << "\n";
        return 1;
    }
}