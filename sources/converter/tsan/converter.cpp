/* 
 * Convert trace generated by the KEDR into format which may be
 * processed by Thread Sanitizer.
 */

#include <kedr/kedr_trace_reader/kedr_trace_reader.h>

#include <kedr/object_types.h> /* Enumerations describing events */

#include <iostream>
#include <stdexcept>

#include <iomanip>

#include <vector>
#include <map>

#include <gelf.h>

#include <stdio.h>
#include <errno.h>
#include <cstring>
#include <unistd.h>
#include <stdlib.h>

#include <fcntl.h>

#include <getopt.h>

#include <cassert>

using namespace std;

/* Wrapper around addresses for template extracting and pretty printing */
template<class T>
struct Addr;

template<>
struct Addr<uint32_t>
{
    uint32_t addr;
    
    Addr(uint32_t addr) : addr(addr) {}
    
#ifndef KEDR_DEBUG
    Addr(const CTFVarInt& var, CTFContext& context):
        addr(var.getUInt32(context)) {}
#else
    Addr(const CTFVarInt& var, CTFContext& context)
        {assert(var.isExist(context) == 1); addr = var.getUInt32(context);}
#endif /* KEDR_DEBUG */


    /* For comparision */
    operator uint32_t(void) const {return addr;}
};

template<>
struct Addr<uint64_t>
{
    uint64_t addr;

    Addr(uint64_t addr) : addr(addr) {}

#ifndef KEDR_DEBUG
    Addr(const CTFVarInt& var, CTFContext& context):
        addr(var.getUInt64(context)) {}
#else
    Addr(const CTFVarInt& var, CTFContext& context)
        {assert(var.isExist(context) == 1); addr = var.getUInt64(context); }
#endif /* KEDR_DEBUG */

    /* For comparision */
    operator uint64_t(void) const {return addr;}
};


template<class T>
ostream& operator<<(ostream& os, const struct Addr<T>& addr)
{
    ios_base::fmtflags oldFlags = os.flags();
    
    os << hex << addr.addr;
    
    os.flags(oldFlags);
    
    return os;
}


/* Wrapper around addresses for template extracting and pretty printing */
template<class T>
struct Size;

template<>
struct Size<uint32_t>
{
    uint32_t size;

#ifndef KEDR_DEBUG
    Size(const CTFVarInt& var, CTFContext& context):
        size(var.getUInt32(context)) {}
#else
    Size(const CTFVarInt& var, CTFContext& context)
        {assert(var.isExist(context) == 1); size = var.getUInt32(context); }
#endif /* KEDR_DEBUG */
};

template<>
struct Size<uint64_t>
{
    uint64_t size;

#ifndef KEDR_DEBUG
    Size(const CTFVarInt& var, CTFContext& context):
        size(var.getUInt64(context)) {}
#else
    Size(const CTFVarInt& var, CTFContext& context)
        {assert(var.isExist(context) == 1); size = var.getUInt64(context); }
#endif /* KEDR_DEBUG */
    

};


template<class T>
ostream& operator<<(ostream& os, const struct Size<T>& size)
{
    ios_base::fmtflags oldFlags = os.flags();
    
    os << hex << size.size;
    
    os.flags(oldFlags);
    
    return os;
}

/* Wrapper around thread identificator for pretty printing */
struct Tid
{
    Tid(int tid): tid(tid){}
    
    Tid& operator=(const Tid& tid) {this->tid = tid.tid; return *this;}
    Tid& operator=(int tid) {this->tid = tid; return *this;}
    
    operator int(void) const {return tid;}
    
    int tid;
};

ostream& operator<<(ostream& os, const struct Tid& tid)
{
    ios_base::fmtflags oldFlags = os.flags();
    
    os << hex << tid.tid;
    
    os.flags(oldFlags);
    
    return os;
}


/* Helpers for search typed variables */
static const CTFVarInt& findInt(const CTFReader& reader, const string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        cerr << "Failed to find integer variable '" << name << "'.\n";
        throw invalid_argument("Invalid variable name");
    }
    if(!var->isInt())
    {
        cerr << "Variable with name '" << name << "' is not integer.\n";
        throw invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarInt*>(var);
}

static const CTFVarEnum& findEnum(const CTFReader& reader, const string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        cerr << "Failed to find enumeration variable '" << name << "'.\n";
        throw invalid_argument("Invalid variable name");
    }
    if(!var->isEnum())
    {
        cerr << "Variable with name '" << name << "' is not enumeration.\n";
        throw invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarEnum*>(var);
}

static const CTFVarArray& findArray(const CTFReader& reader, const string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        cerr << "Failed to find array-like variable '" << name << "'.\n";
        throw invalid_argument("Invalid variable name");
    }
    if(!var->isArray())
    {
        cerr << "Variable with name '" << name << "' is not array-like.\n";
        throw invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarArray*>(var);
}

/*************************** ThreadInfo *******************************/
/* 
 * Information about thread, which may be used by different layers of
 * trace processing.
 */

template<class T>
struct ThreadInfo
{
    /*
     * Address of task, corresponded to the thread.
     * 
     * Used as key in map, so its 'const' modificator.
     */
    const Addr<T> addr;
    /* Index of the thread */
    Tid tid;
    /* Whether starting of the thread is reflected in the converted trace */
    bool isStarted;
    /* 
     * If call_pre CTF event was issued for the thread without call_post,
     * this address contain PC for that event.
     * 
     * It used for restore NULL-PCs, which are originated from model
     * of the global functions.
     */
    Addr<T> callAddr;
    /* 
     * Whether last event is memory access.
     * 
     * Used for (re)group memory accesses into block after restored
     * 'lock' operations prefixes are change operation type.
     */
    bool lastIsMA;
    //TODO: other fields
    
    ThreadInfo(const Addr<T> addr, int id):
        addr(addr), tid(id), isStarted(false), callAddr(0) {}
};


/* Map of threads. Maps thread address into ThreadInfo structure.*/
template<class T>
class ThreadMap
{
public:
    ThreadMap(void) : nextID(0) {}
    
    ThreadInfo<T>* find(Addr<T> addr)
    {
        typename map<Addr<T>, ThreadInfo<T> >::iterator iter = threads.find(addr);
        return iter != threads.end() ? &iter->second : NULL;
        return NULL;
    }
    
    ThreadInfo<T>* add(Addr<T> addr)
    {
        pair<typename map<Addr<T>, ThreadInfo<T> >::iterator, bool>
            iter = threads.insert(make_pair(
                addr, ThreadInfo<T>(addr, nextID)));
        if(!iter.second)
        {
            cerr << "Attempt to add thread information for already known thread.\n";
            throw logic_error("Converter error");
        }
        
        nextID++;
        return &iter.first->second;
    }
    
    void remove(Addr<T> addr)
    {
        typename map<Addr<T>, ThreadInfo<T> >::iterator iter = threads.find(addr);
        if(iter != threads.end()) threads.erase(iter);
    }
private:
    map<Addr<T>, ThreadInfo<T> > threads;
    
    int nextID;
};

/***************** Process CTF event in KEDR trace ********************/
/*
 * Abstract class which process events in KEDR trace.
 * 
 * Its methods accept iterators, so them may perform forward lookups.
 * 
 * Defaults are do nothing.
 */

/* Forward declaration */
class KEDRTraceProcessor;

class KEDREventProcessor
{
public:
    virtual ~KEDREventProcessor() {}

    virtual void processFunctionEntry(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processFunctionExit(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processCallPre(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processCallPost(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processMA(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processLMAUpdate(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processLMARead(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processLMAWrite(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processIOMA(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processMRB(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processMWB(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processMFB(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processAlloc(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processFree(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processLock(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processUnlock(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processRLock(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processRUnlock(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void process(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processSignal(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processWait(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processThreadCreateBefore(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processThreadCreateAfter(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    virtual void processThreadJoin(
        const KEDRTraceReader::EventIterator& /*iter*/) {}
    /* For any unknown event. */
    virtual void processUnknown(
        const KEDRTraceReader::EventIterator& /*iter*/) {}

protected:
    /* Method which may be used for stop trace processing */
    void stop(void) {shouldStop = true;}
    /* 
     * Trace processor with which given object is currently used.
     * May be used for forward lookup.
     */
    KEDRTraceProcessor* currentTraceProcessor;
private:
    /* This variable is initialized and checked by trace processor */
    bool shouldStop;
    friend class KEDRTraceProcessor;
};

/*********************** Processor of KEDR trace **********************/
/* 
 * Process trace generated by the KEDR.
 * 
 * Use KEDREventProcessor as backend.
 */

class KEDRTraceProcessor
{
public:

    KEDRTraceProcessor(KEDRTraceReader& traceReader);
    /* Process whole trace using given event processor */
    void process(KEDREventProcessor& eventProcessor);
    /* 
     * Process trace starting from given iterator using given event
     * processor.
     * 
     * After event is processed, shouldStop flag of event processor is
     * cheked. If it is true, processing is stopped. Otherwise, iterator
     * is advanced and next cycle of processing is performed
     * (until iterator become at-the-end iterator).
     */
    void process(KEDREventProcessor& eventProcessor,
        KEDRTraceReader::EventIterator& iter);
private:
    KEDRTraceReader& traceReader;
    
    const CTFVarEnum& eventTypeVar;
    
    typedef void (*processEvent_t)(KEDREventProcessor& eventProcessor,
        KEDRTraceReader::EventIterator& iter);
    
    vector<processEvent_t> processEventHandlers;
};


static void _traceProcessorProcessFunctionEntry(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processFunctionEntry(iter);
}

static void _traceProcessorProcessFunctionExit(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processFunctionExit(iter);
}

static void _traceProcessorProcessCallPre(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processCallPre(iter);
}

static void _traceProcessorProcessCallPost(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processCallPost(iter);
}

static void _traceProcessorProcessMA(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processMA(iter);
}

static void _traceProcessorProcessLMAUpdate(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processLMAUpdate(iter);
}

static void _traceProcessorProcessLMARead(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processLMARead(iter);
}

static void _traceProcessorProcessLMAWrite(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processLMAWrite(iter);
}

static void _traceProcessorProcessIOMA(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processIOMA(iter);
}

static void _traceProcessorProcessMRB(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processMRB(iter);
}

static void _traceProcessorProcessMWB(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processMWB(iter);
}

static void _traceProcessorProcessMFB(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processMFB(iter);
}

static void _traceProcessorProcessAlloc(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processAlloc(iter);
}

static void _traceProcessorProcessFree(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processFree(iter);
}

static void _traceProcessorProcessLock(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processLock(iter);
}

static void _traceProcessorProcessUnlock(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processUnlock(iter);
}

static void _traceProcessorProcessRLock(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processRLock(iter);
}

static void _traceProcessorProcessRUnlock(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processRUnlock(iter);
}

static void _traceProcessorProcessSignal(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processSignal(iter);
}

static void _traceProcessorProcessWait(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processWait(iter);
}

static void _traceProcessorProcessThreadCreateBefore(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processThreadCreateBefore(iter);
}

static void _traceProcessorProcessThreadCreateAfter(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processThreadCreateAfter(iter);
}

static void _traceProcessorProcessThreadJoin(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processThreadJoin(iter);
}

static void _traceProcessorProcessUnknown(
    KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processUnknown(iter);
}



KEDRTraceProcessor::KEDRTraceProcessor(KEDRTraceReader& traceReader)
    : traceReader(traceReader),
    eventTypeVar(findEnum(traceReader, "stream.event.header.type"))
{
    const CTFTypeEnum* eventTypeEnum = eventTypeVar.getType();
    int nValues = eventTypeEnum->getNValues();
    
    processEventHandlers.reserve(nValues);
    
    for(int i = 0; i < nValues; i++)
    {
        const string& eventType = eventTypeEnum->valueToStr(i);

        processEvent_t eventHandler;
        
        if(eventType == "fentry")
            eventHandler = &_traceProcessorProcessFunctionEntry;
        else if(eventType == "fexit")
            eventHandler = &_traceProcessorProcessFunctionExit;
        else if(eventType == "fcpre")
            eventHandler = &_traceProcessorProcessCallPre;
        else if(eventType == "fcpost")
            eventHandler = &_traceProcessorProcessCallPost;
        else if(eventType == "ma")
            eventHandler = &_traceProcessorProcessMA;
        else if(eventType == "lma_update")
            eventHandler = &_traceProcessorProcessLMAUpdate;
        else if(eventType == "lma_read")
            eventHandler = &_traceProcessorProcessLMARead;
        else if(eventType == "lma_write")
            eventHandler = &_traceProcessorProcessLMAWrite;
        else if(eventType == "ioma")
            eventHandler = &_traceProcessorProcessIOMA;
        else if(eventType == "mwb")
            eventHandler = &_traceProcessorProcessMWB;
        else if(eventType == "mrb")
            eventHandler = &_traceProcessorProcessMRB;
        else if(eventType == "mfb")
            eventHandler = &_traceProcessorProcessMFB;
        else if(eventType == "alloc")
            eventHandler = &_traceProcessorProcessAlloc;
        else if(eventType == "free")
            eventHandler = &_traceProcessorProcessFree;
        else if(eventType == "lock")
            eventHandler = &_traceProcessorProcessLock;
        else if(eventType == "unlock")
            eventHandler = &_traceProcessorProcessUnlock;
        else if(eventType == "rlock")
            eventHandler = &_traceProcessorProcessRLock;
        else if(eventType == "runlock")
            eventHandler = &_traceProcessorProcessRUnlock;
        else if(eventType == "signal")
            eventHandler = &_traceProcessorProcessSignal;
        else if(eventType == "wait")
            eventHandler = &_traceProcessorProcessWait;
        else if(eventType == "tcreate_before")
            eventHandler = &_traceProcessorProcessThreadCreateBefore;
        else if(eventType == "tcreate_after")
            eventHandler = &_traceProcessorProcessThreadCreateAfter;
        else if(eventType == "tjoin")
            eventHandler = &_traceProcessorProcessThreadJoin;
        else
            eventHandler = &_traceProcessorProcessUnknown;
        
        processEventHandlers.push_back(eventHandler);
    }
}

void KEDRTraceProcessor::process(KEDREventProcessor& eventProcessor)
{
    eventProcessor.currentTraceProcessor = this;
    KEDRTraceReader::EventIterator iter(traceReader);
    for(;
        iter;
        ++iter)
    {
        int index = eventTypeVar.getValue(*iter);
        processEventHandlers[index](eventProcessor, iter);
    }
    eventProcessor.currentTraceProcessor = NULL;
}
void KEDRTraceProcessor::process(KEDREventProcessor& eventProcessor,
    KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.currentTraceProcessor = this;
    eventProcessor.shouldStop = false;
    for(;
        iter && !eventProcessor.shouldStop;
        ++iter)
    {
        int index = eventTypeVar.getValue(*iter);
        processEventHandlers[index](eventProcessor, iter);
    }
    eventProcessor.currentTraceProcessor = NULL;
}

/************************* Printer of tsan events**********************/
/* Print events in tsan sence into stream */
template<class T>
class TsanEventPrinter
{
public:
    TsanEventPrinter(ostream& os): os(os) {}

    void printThreadStart(Tid tid, Tid parentTid = 0) const
        {os << "THR_START " << tid << " 0 0 " << parentTid << "\n";}
    void printThreadEnd(Tid tid) const
        {os << "THR_END " << tid << " 0 0 0\n";}
    void printRead(Tid tid, Addr<T> pc, Addr<T> addr, Size<T> size) const
        {os << "READ " << tid << " " << pc << " " << addr << " " << size << "\n";}
    void printWrite(Tid tid, Addr<T> pc, Addr<T> addr, Size<T> size) const
        {os << "WRITE " << tid << " " << pc << " " << addr << " " << size << "\n";}
    void printSignal(Tid tid, Addr<T> pc, Addr<T> obj) const
        {os << "SIGNAL " << tid << " " << pc << " " << obj << " 0\n";}
    void printWait(Tid tid, Addr<T> pc, Addr<T> obj) const
        {os << "WAIT " << tid << " " << pc << " " << obj << " 0\n";}
    void printFunctionCall(Tid tid, Addr<T> pc) const
        {os << "RTN_CALL " << tid << " " << pc << " 0 0\n";}
    void printFunctionExit(Tid tid) const
        {os << "RTN_EXIT " << tid << " 0 0 0\n";}
    void printLock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {os << "WRITER_LOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void printRLock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {os << "READER_LOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void printUnlock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {os << "UNLOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void printAlloc(Tid tid, Addr<T> pc, Size<T> size, Addr<T> pointer) const
        {os << "MALLOC " << tid << " " << pc << " " << pointer << " " << size << "\n";}
    void printFree(Tid tid, Addr<T> pc, Addr<T> pointer) const
        {os << "FREE " << tid << " " << pc << " " << pointer << " 0\n";}
    void printThreadCreateBefore(Tid tid, Addr<T> pc) const
        {os << "THR_CREATE_BEFORE " << tid << " " << pc << " 0 0\n";}
    void printThreadCreateAfter(Tid tid, Tid childTid) const
        {os << "THR_CREATE_AFTER " << tid << " 0 " << childTid << " 0\n";}
    void printThreadJoin(Tid tid, Addr<T> pc, Tid childTid) const
        {os << "THR_JOIN_AFTER " << tid << " " << pc << " " << childTid << " 0\n";}
    void printBlock(Tid tid, Addr<T> pc) const
        {os << "SBLOCK_ENTER " << tid << " " << pc << " 0 0\n";}
    
    ostream& commentBegin(void) const {return os << "# ";}
    void commentEnd(void) const {os << "\n";}
private:
    ostream& os;
};

/****************** Process event in some intermediate format *********/
/* 
 * Abstract class for process event using parameters of that event.
 * 
 * Threads are already resolved into ThreadInfo.
 * 
 * Lookups cannot be done at this stage.
 * 
 * Default implementation do nothing.
 */
template<class T>
class EventProcessor
{
public:
    virtual ~EventProcessor() {}

    virtual void processFunctionEntry(ThreadInfo<T>* /*thread*/,
        Addr<T> /*func*/) {}
    virtual void processFunctionExit(ThreadInfo<T>* /*thread*/,
        Addr<T> /*func*/) {}
    virtual void processCallPre(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*func*/) {}
    virtual void processCallPost(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*func*/) {}
    virtual void processMAStart(ThreadInfo<T>* /*thread*/,
        int /*nEvents*/) {}
    virtual void processMA(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*addr*/, Size<T> /*size*/,
        enum kedr_memory_event_type /*type*/) {}
    virtual void processLMAUpdate(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*addr*/, Size<T> /*size*/) {}
    virtual void processLMARead(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*addr*/, Size<T> /*size*/) {}
    virtual void processLMAWrite(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*addr*/, Size<T> /*size*/) {}
    virtual void processIOMA(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*addr*/, Size<T> /*size*/,
        enum kedr_memory_event_type /*type*/) {}
    virtual void processMRB(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/) {}
    virtual void processMWB(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/) {}
    virtual void processMFB(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/) {}
    virtual void processAlloc(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Size<T> /*size*/, Addr<T> /*pointer*/) {}
    virtual void processFree(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*pointer*/) {}
    virtual void processLock(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*obj*/,
        enum kedr_lock_type /*type*/) {}
    virtual void processUnlock(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*obj*/,
        enum kedr_lock_type /*type*/) {}
    virtual void processRLock(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*obj*/,
        enum kedr_lock_type /*type*/) {}
    virtual void processRUnlock(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, Addr<T> /*obj*/,
        enum kedr_lock_type /*type*/) {}
    virtual void processSignal(ThreadInfo<T>* /*thread*/, Addr<T> /*pc*/,
        Addr<T> /*obj*/, enum kedr_sw_object_type /*type*/) {}
    virtual void processWait(ThreadInfo<T>* /*thread*/, Addr<T> /*pc*/,
        Addr<T> /*obj*/, enum kedr_sw_object_type /*type*/) {}
    virtual void processThreadCreateBefore(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/) {}
    virtual void processThreadCreateAfter(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, ThreadInfo<T>* /*childThread*/) {}
    virtual void processThreadJoin(ThreadInfo<T>* /*thread*/,
        Addr<T> /*pc*/, ThreadInfo<T>* /*childThread*/) {}
    
    /* Event types derived from CTF trace */
    virtual void processThreadStart(ThreadInfo<T>* /*thread*/,
        ThreadInfo<T>* /*parentThread*/) {}
    virtual void processThreadStop(ThreadInfo<T>* /*thread*/) {}
};


/******** Standard implementation of KEDR event processor**************/
/* 
 * Use EventProcessor as backend.
 * 
 * Every thread address is converted into ThreadInfo(new or existed one).
 * 
 * Extract child thread for ThreadCreateBefore event using forward lookup.
 */

template<class T>
class KEDREventProcessorStandard: public KEDREventProcessor
{
public:
    KEDREventProcessorStandard(const KEDRTraceReader& traceReader,
        EventProcessor<T>* eventProcessor);

    ~KEDREventProcessorStandard() {delete &eventProcessor;}

    void processFunctionEntry(
        const KEDRTraceReader::EventIterator& iter);
    void processFunctionExit(
        const KEDRTraceReader::EventIterator& iter);
    void processCallPre(
        const KEDRTraceReader::EventIterator& iter);
    void processCallPost(
        const KEDRTraceReader::EventIterator& iter);
    void processMA(
        const KEDRTraceReader::EventIterator& iter);
    void processLMAUpdate(
        const KEDRTraceReader::EventIterator& iter);
    void processLMARead(
        const KEDRTraceReader::EventIterator& iter);
    void processLMAWrite(
        const KEDRTraceReader::EventIterator& iter);
    void processIOMA(
        const KEDRTraceReader::EventIterator& iter);
    void processMRB(
        const KEDRTraceReader::EventIterator& iter);
    void processMWB(
        const KEDRTraceReader::EventIterator& iter);
    void processMFB(
        const KEDRTraceReader::EventIterator& iter);
    void processAlloc(
        const KEDRTraceReader::EventIterator& iter);
    void processFree(
        const KEDRTraceReader::EventIterator& iter);
    void processLock(
        const KEDRTraceReader::EventIterator& iter);
    void processUnlock(
        const KEDRTraceReader::EventIterator& iter);
    void processRLock(
        const KEDRTraceReader::EventIterator& iter);
    void processRUnlock(
        const KEDRTraceReader::EventIterator& iter);
    void processSignal(
        const KEDRTraceReader::EventIterator& iter);
    void processWait(
        const KEDRTraceReader::EventIterator& iter);
    void processThreadCreateBefore(
        const KEDRTraceReader::EventIterator& iter);
    void processThreadCreateAfter(
        const KEDRTraceReader::EventIterator& iter);
    void processThreadJoin(
        const KEDRTraceReader::EventIterator& iter);

    void processUnknown(
        const KEDRTraceReader::EventIterator& iter)
            {cerr << "Event of unknown type: " << eventTypeVar.getInt32(*iter) << ".\n";}

private:
    ThreadMap<T> threads;
    EventProcessor<T>& eventProcessor;
    
    /* 
     * Find thread info for tid or create new one.
     * 
     * For newly created thread info call eventProcessor.processThreadStart().
     */
    ThreadInfo<T>* getThreadInfo(const KEDRTraceReader::EventIterator& iter);
    /* Helper event processor for find child tid for thread create before event */
    class ChildTidFinder: private KEDREventProcessor
    {
    public:
        ChildTidFinder(KEDREventProcessorStandard<T>& outer)
            : outer(outer), threadAddr(0), resultedTid(0) {}
        /* 
         * Look for event of type 'tcreate_after' in given thread.
         * Value of 'child_tid' in that event will be returned.
         * 
         * Iterator passed to the function will be used for search.
         */
        Addr<T> findChildTid(KEDRTraceReader::EventIterator& iter,
            Addr<T> threadAddr)
        {
            this->threadAddr = threadAddr;
            found = false;
            outer.currentTraceProcessor->process(*this, iter);
            if(!found)
            {
                cerr << "No 'tcreate_after' event corresponds to 'tcreate_before'\n";
                throw logic_error("Incorrect KEDR trace");
            }
            return resultedTid;
        }
        
        void processThreadCreateAfter(
            const KEDRTraceReader::EventIterator& iter)
        {
            if(Addr<T>(outer.tidVar, *iter) != threadAddr) return;

            resultedTid = Addr<T>(outer.TCAVarTid, *iter);
            found = true;
            stop();
        }

    private:
        KEDREventProcessorStandard<T>& outer;
        
        Addr<T> threadAddr;
        Addr<T> resultedTid;
        bool found;
    } childTidFinder;

    /* One variable for all event types */
    const CTFVarInt& tidVar;
    
    /* Function entry */
    const CTFVarInt& FEntryVarFunc;
    
    /* Function exit */
    const CTFVarInt& FExitVarFunc;
    
    /* Call pre*/
    const CTFVarInt& CallPreVarPC;
    const CTFVarInt& CallPreVarFunc;
    
    /* Call post*/
    const CTFVarInt& CallPostVarPC;
    const CTFVarInt& CallPostVarFunc;
    
    /* Memory accesses */
    const CTFVarArray& MAVarElements;
    /* Per-access variables*/
    const CTFVarInt& MASVarPC;
    const CTFVarInt& MASVarAddr;
    const CTFVarInt& MASVarSize;
    const CTFVarInt& MASVarType;
    
    /* Locked memory update */
    const CTFVarInt& LMUVarPC;
    const CTFVarInt& LMUVarAddr;
    const CTFVarInt& LMUVarSize;

    /* Locked memory read */
    const CTFVarInt& LMRVarPC;
    const CTFVarInt& LMRVarAddr;
    const CTFVarInt& LMRVarSize;
    
    /* Locked memory write */
    const CTFVarInt& LMWVarPC;
    const CTFVarInt& LMWVarAddr;
    const CTFVarInt& LMWVarSize;
    
    /* I/O memory access */
    const CTFVarInt& IOMAVarPC;
    const CTFVarInt& IOMAVarAddr;
    const CTFVarInt& IOMAVarSize;
    const CTFVarInt& IOMAVarType;

    /* Memory read barrier */
    const CTFVarInt& MRBVarPC;

    /* Memory write barrier */
    const CTFVarInt& MWBVarPC;

    /* Memory full barrier */
    const CTFVarInt& MFBVarPC;

    /* Alloc */
    const CTFVarInt& AllocVarPC;
    const CTFVarInt& AllocVarSize;
    const CTFVarInt& AllocVarPointer;

    /* Free */
    const CTFVarInt& FreeVarPC;
    const CTFVarInt& FreeVarPointer;

    /* Lock */
    const CTFVarInt& LockVarPC;
    const CTFVarInt& LockVarObj;
    const CTFVarInt& LockVarType;

    /* Unlock */
    const CTFVarInt& UnlockVarPC;
    const CTFVarInt& UnlockVarObj;
    const CTFVarInt& UnlockVarType;

    /* Read lock */
    const CTFVarInt& RLockVarPC;
    const CTFVarInt& RLockVarObj;
    const CTFVarInt& RLockVarType;

    /* Read unlock */
    const CTFVarInt& RUnlockVarPC;
    const CTFVarInt& RUnlockVarObj;
    const CTFVarInt& RUnlockVarType;

    /* Signal */
    const CTFVarInt& SignalVarPC;
    const CTFVarInt& SignalVarObj;
    const CTFVarInt& SignalVarType;

    /* Wait */
    const CTFVarInt& WaitVarPC;
    const CTFVarInt& WaitVarObj;
    const CTFVarInt& WaitVarType;

    /* Thread create before */
    const CTFVarInt& TCBVarPC;

    /* Thread create after */
    const CTFVarInt& TCAVarPC;
    const CTFVarInt& TCAVarTid;

    /* Thread join */
    const CTFVarInt& TJVarPC;
    const CTFVarInt& TJVarTid;

    /* Unknown event */
    const CTFVarEnum& eventTypeVar;
};

template<class T>
KEDREventProcessorStandard<T>::KEDREventProcessorStandard(
    const KEDRTraceReader& traceReader, EventProcessor<T>* eventProcessor)
    : eventProcessor(*eventProcessor),
    childTidFinder(*this),
    tidVar(findInt(traceReader, "stream.event.context.tid")),
/* Macro for store event's variable, integer type */
#define SV(var, type, subname) var(findInt(traceReader, "event.fields." type "." subname))
    
    SV(FEntryVarFunc, "fentry", "func"),
    
    SV(FExitVarFunc, "fexit", "func"),
    
    SV(CallPreVarPC, "fcpre", "pc"),
    SV(CallPreVarFunc, "fcpre", "func"),
    
    SV(CallPostVarPC, "fcpost", "pc"),
    SV(CallPostVarFunc, "fcpost", "func"),
    
    MAVarElements(findArray(traceReader, "event.fields.ma")),
    SV(MASVarPC, "ma[]", "pc"),
    SV(MASVarAddr, "ma[]", "addr"),
    SV(MASVarSize, "ma[]", "size"),
    SV(MASVarType, "ma[]", "access_type"),
    
    SV(LMUVarPC, "lma_update", "pc"),
    SV(LMUVarAddr, "lma_update", "addr"),
    SV(LMUVarSize, "lma_update", "size"),
    
    SV(LMRVarPC, "lma_read", "pc"),
    SV(LMRVarAddr, "lma_read", "addr"),
    SV(LMRVarSize, "lma_read", "size"),
    
    SV(LMWVarPC, "lma_write", "pc"),
    SV(LMWVarAddr, "lma_write", "addr"),
    SV(LMWVarSize, "lma_write", "size"),
    
    SV(IOMAVarPC, "ioma", "pc"),
    SV(IOMAVarAddr, "ioma", "addr"),
    SV(IOMAVarSize, "ioma", "size"),
    SV(IOMAVarType, "ioma", "access_type"),
    
    SV(MRBVarPC, "mrb", "pc"),
    
    SV(MWBVarPC, "mwb", "pc"),
    
    SV(MFBVarPC, "mfb", "pc"),
    
    SV(AllocVarPC, "alloc", "pc"),
    SV(AllocVarSize, "alloc", "size"),
    SV(AllocVarPointer, "alloc", "pointer"),
    
    SV(FreeVarPC, "free", "pc"),
    SV(FreeVarPointer, "free", "pointer"),
    
    SV(LockVarPC, "lock", "pc"),
    SV(LockVarObj, "lock", "object"),
    SV(LockVarType, "lock", "type"),

    SV(UnlockVarPC, "unlock", "pc"),
    SV(UnlockVarObj, "unlock", "object"),
    SV(UnlockVarType, "unlock", "type"),
    
    SV(RLockVarPC, "rlock", "pc"),
    SV(RLockVarObj, "rlock", "object"),
    SV(RLockVarType, "rlock", "type"),

    SV(RUnlockVarPC, "runlock", "pc"),
    SV(RUnlockVarObj, "runlock", "object"),
    SV(RUnlockVarType, "runlock", "type"),
    
    SV(SignalVarPC, "signal", "pc"),
    SV(SignalVarObj, "signal", "object"),
    SV(SignalVarType, "signal", "type"),

    SV(WaitVarPC, "wait", "pc"),
    SV(WaitVarObj, "wait", "object"),
    SV(WaitVarType, "wait", "type"),

    SV(TCBVarPC, "tcreate_before", "pc"),
    
    SV(TCAVarPC, "tcreate_after", "pc"),
    SV(TCAVarTid, "tcreate_after", "child_tid"),

    SV(TJVarPC, "tjoin", "pc"),
    SV(TJVarTid, "tjoin", "child_tid"),
#undef SV
    eventTypeVar(findEnum(traceReader, "stream.event.header.type"))
{
}

template<class T>
void KEDREventProcessorStandard<T>::processFunctionEntry(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processFunctionEntry(getThreadInfo(iter),
        Addr<T>(FEntryVarFunc, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processFunctionExit(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processFunctionExit(getThreadInfo(iter),
        Addr<T>(FExitVarFunc, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processCallPre(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processCallPre(getThreadInfo(iter),
        Addr<T>(CallPreVarPC, *iter), Addr<T>(CallPreVarFunc, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processCallPost(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processCallPost(getThreadInfo(iter),
        Addr<T>(CallPostVarPC, *iter), Addr<T>(CallPostVarFunc, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processMA(
    const KEDRTraceReader::EventIterator& iter)
{
    ThreadInfo<T>* threadInfo = getThreadInfo(iter);
    int nEvents = MAVarElements.getNElems(*iter);
    eventProcessor.processMAStart(threadInfo, nEvents);
    
    for(CTFVarArray::ElemIterator elemIter(MAVarElements, *iter);
        elemIter;
        ++elemIter)
    {
        eventProcessor.processMA(threadInfo,
            Addr<T>(MASVarPC, *elemIter),
            Addr<T>(MASVarAddr, *elemIter),
            Size<T>(MASVarSize, *elemIter),
            (enum kedr_memory_event_type)MASVarType.getUInt32(*elemIter));
    }
}

template<class T>
void KEDREventProcessorStandard<T>::processLMAUpdate(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processLMAUpdate(getThreadInfo(iter),
        Addr<T>(LMUVarPC, *iter),
        Addr<T>(LMUVarAddr, *iter),
        Size<T>(LMUVarSize, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processLMARead(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processLMARead(getThreadInfo(iter),
        Addr<T>(LMRVarPC, *iter),
        Addr<T>(LMRVarAddr, *iter),
        Size<T>(LMRVarSize, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processLMAWrite(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processLMAWrite(getThreadInfo(iter),
        Addr<T>(LMWVarPC, *iter),
        Addr<T>(LMWVarAddr, *iter),
        Size<T>(LMWVarSize, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processIOMA(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processIOMA(getThreadInfo(iter),
        Addr<T>(IOMAVarPC, *iter),
        Addr<T>(IOMAVarAddr, *iter),
        Size<T>(IOMAVarSize, *iter),
        (enum kedr_memory_event_type)IOMAVarType.getUInt32(*iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processMRB(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processMRB(getThreadInfo(iter),
        Addr<T>(MRBVarPC, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processMWB(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processMWB(getThreadInfo(iter),
        Addr<T>(MWBVarPC, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processMFB(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processMFB(getThreadInfo(iter),
        Addr<T>(MFBVarPC, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processAlloc(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processAlloc(getThreadInfo(iter),
        Addr<T>(AllocVarPC, *iter),
        Size<T>(AllocVarSize, *iter),
        Addr<T>(AllocVarPointer, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processFree(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processFree(getThreadInfo(iter),
        Addr<T>(FreeVarPC, *iter),
        Addr<T>(FreeVarPointer, *iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processLock(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processLock(getThreadInfo(iter),
        Addr<T>(LockVarPC, *iter),
        Addr<T>(LockVarObj, *iter),
        (enum kedr_lock_type)LockVarType.getUInt32(*iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processUnlock(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processUnlock(getThreadInfo(iter),
        Addr<T>(UnlockVarPC, *iter),
        Addr<T>(UnlockVarObj, *iter),
        (enum kedr_lock_type)UnlockVarType.getUInt32(*iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processRLock(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processRLock(getThreadInfo(iter),
        Addr<T>(RLockVarPC, *iter),
        Addr<T>(RLockVarObj, *iter),
        (enum kedr_lock_type)RLockVarType.getUInt32(*iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processRUnlock(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processRUnlock(getThreadInfo(iter),
        Addr<T>(RUnlockVarPC, *iter),
        Addr<T>(RUnlockVarObj, *iter),
        (enum kedr_lock_type)RUnlockVarType.getUInt32(*iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processSignal(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processSignal(getThreadInfo(iter),
        Addr<T>(SignalVarPC, *iter),
        Addr<T>(SignalVarObj, *iter),
        (enum kedr_sw_object_type)SignalVarType.getUInt32(*iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processWait(
    const KEDRTraceReader::EventIterator& iter)
{
    eventProcessor.processWait(getThreadInfo(iter),
        Addr<T>(WaitVarPC, *iter),
        Addr<T>(WaitVarObj, *iter),
        (enum kedr_sw_object_type)WaitVarType.getUInt32(*iter));
}

template<class T>
void KEDREventProcessorStandard<T>::processThreadCreateBefore(
    const KEDRTraceReader::EventIterator& iter)
{
    ThreadInfo<T>* threadInfo = getThreadInfo(iter);
    
    KEDRTraceReader::EventIterator iterClone = iter.clone();
    ++iterClone;
    
    Addr<T> childThreadAddr = childTidFinder.findChildTid(iterClone,
        threadInfo->addr);
    
    if(childThreadAddr == 0) return;/* Thread creation will fail.*/

    ThreadInfo<T>* childThreadInfo = threads.find(childThreadAddr);
    if(childThreadInfo)
    {
        eventProcessor.processThreadStop(childThreadInfo);
        childThreadInfo->isStarted = false;
        threads.remove(childThreadAddr);
    }
    childThreadInfo = threads.add(childThreadAddr);

    eventProcessor.processThreadCreateBefore(threadInfo,
        Addr<T>(TCBVarPC, *iter));
    
    eventProcessor.processThreadStart(childThreadInfo, threadInfo);
    childThreadInfo->isStarted = true;
}

template<class T>
void KEDREventProcessorStandard<T>::processThreadCreateAfter(
    const KEDRTraceReader::EventIterator& iter)
{
    Addr<T> childTidAddr(TCAVarTid, *iter);

    ThreadInfo<T>* childThreadInfo = threads.find(childTidAddr);
    if(childThreadInfo == NULL)
    {
        cerr << "'thread create after' without previous 'thread create before'.\n";
        throw logic_error("Incorrect KEDR trace.");
    }

    eventProcessor.processThreadCreateAfter(getThreadInfo(iter),
        Addr<T>(TCAVarPC, *iter), childThreadInfo);
}

template<class T>
void KEDREventProcessorStandard<T>::processThreadJoin(
    const KEDRTraceReader::EventIterator& iter)
{
    Addr<T> childTidAddr(TCAVarTid, *iter);

    ThreadInfo<T>* childThreadInfo = threads.find(childTidAddr);
    if(childThreadInfo == NULL)
    {
        cerr << "Join on thread which wasn't started.\n";
        throw logic_error("Incorrect KEDR trace.");
    }

    eventProcessor.processThreadJoin(getThreadInfo(iter),
        Addr<T>(TCAVarPC, *iter), childThreadInfo);
}


template<class T>
ThreadInfo<T>* KEDREventProcessorStandard<T>::getThreadInfo(
    const KEDRTraceReader::EventIterator& iter)
{
    Addr<T> threadAddr(tidVar, *iter);
    ThreadInfo<T>* threadInfo = threads.find(threadAddr);
    if(threadInfo == NULL)
    {
        threadInfo = threads.add(threadAddr);
        //TODO: NULL should be replaced with thread with ID=0.
        eventProcessor.processThreadStart(threadInfo, NULL);
        threadInfo->isStarted = true;
    }
    return threadInfo;
}

/*************** Standard converter into Tsan events*******************/
/* Converts intermediate event into tsan event. */
template<class T>
class EventProcessorTsan: public EventProcessor<T>,
    protected TsanEventPrinter<T>
{
public:
    EventProcessorTsan(ostream& os) : TsanEventPrinter<T>(os),
        isMAblockStarted(false) {}

    void processCallPre(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> /*func*/)
    {
        TsanEventPrinter<T>::printFunctionCall(thread->tid, pc);
    }
    void processCallPost(ThreadInfo<T>* thread,
        Addr<T> /*pc*/, Addr<T> /*func*/)
    {
        TsanEventPrinter<T>::printFunctionExit(thread->tid);
    }
    void processMAStart(ThreadInfo<T>* /*thread*/, int /*nEvents*/)
    {
        isMAblockStarted = false;
    }
    
    void processMA(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        if(!isMAblockStarted)
        {
            TsanEventPrinter<T>::printBlock(thread->tid, pc);
            isMAblockStarted = true;
        }
        switch(type)
        {
        case KEDR_ET_MREAD:
            TsanEventPrinter<T>::printRead(thread->tid, pc, addr, size);
        break;
        case KEDR_ET_MWRITE:
        case KEDR_ET_MUPDATE:
            TsanEventPrinter<T>::printWrite(thread->tid, pc, addr, size);
        break;
        }
    }

    virtual void processIOMA(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        TsanEventPrinter<T>::printBlock(thread->tid, pc);

        switch(type)
        {
        case KEDR_ET_MREAD:
            TsanEventPrinter<T>::printRead(thread->tid, pc, addr, size);
        break;
        case KEDR_ET_MWRITE:
        case KEDR_ET_MUPDATE:
            TsanEventPrinter<T>::printWrite(thread->tid, pc, addr, size);
        break;
        }
    }

    void processAlloc(ThreadInfo<T>* thread,
        Addr<T> pc, Size<T> size, Addr<T> pointer)
    {
        TsanEventPrinter<T>::printAlloc(thread->tid, pc, size, pointer);
    }
    void processFree(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> pointer)
    {
        TsanEventPrinter<T>::printFree(thread->tid, pc, pointer);
    }

    void processLock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj,
        enum kedr_lock_type /*type*/)
    {
        TsanEventPrinter<T>::printLock(thread->tid, pc, obj);
    }
    void processUnlock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj,
        enum kedr_lock_type /*type*/)
    {
        TsanEventPrinter<T>::printUnlock(thread->tid, pc, obj);
    }
    void processRLock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj,
        enum kedr_lock_type /*type*/)
    {
        TsanEventPrinter<T>::printRLock(thread->tid, pc, obj);
    }
    void processRUnlock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj,
        enum kedr_lock_type /*type*/)
    {
        TsanEventPrinter<T>::printUnlock(thread->tid, pc, obj);
    }
    void processSignal(ThreadInfo<T>* thread, Addr<T> pc,
        Addr<T> obj, enum kedr_sw_object_type /*type*/)
    {
        TsanEventPrinter<T>::printSignal(thread->tid, pc, obj);
    }
    void processWait(ThreadInfo<T>* thread, Addr<T> pc,
        Addr<T> obj, enum kedr_sw_object_type /*type*/)
    {
        TsanEventPrinter<T>::printWait(thread->tid, pc, obj);
    }
    void processThreadCreateBefore(ThreadInfo<T>* thread,
        Addr<T> pc)
    {
        TsanEventPrinter<T>::printThreadCreateBefore(thread->tid, pc);
    }
    void processThreadCreateAfter(ThreadInfo<T>* thread,
        Addr<T> /*pc*/ , ThreadInfo<T>* childThread)
    {
        TsanEventPrinter<T>::printThreadCreateAfter(thread->tid,
            childThread->tid);
    }
    void processThreadJoin(ThreadInfo<T>* thread,
        Addr<T> pc, ThreadInfo<T>* childThread)
    {
        TsanEventPrinter<T>::printThreadJoin(thread->tid, pc,
            childThread->tid);
    }
    
    void processThreadStart(ThreadInfo<T>* thread,
        ThreadInfo<T>* parentThread)
    {
        TsanEventPrinter<T>::commentBegin() << "Thread " << thread->tid
            << " is started (real TID is " << thread->addr << ")";
        TsanEventPrinter<T>::commentEnd();
        TsanEventPrinter<T>::printThreadStart(thread->tid,
            parentThread ? parentThread->tid : Tid(0));
    }
    void processThreadStop(ThreadInfo<T>* thread)
    {
        TsanEventPrinter<T>::printThreadEnd(thread->tid);
    }
protected:
    /* Whether block is started for current memory accesses seria. */
    bool isMAblockStarted;
};

/********************** Base event converter **************************/
/* 
 * Base class for EventProcessor -> EventProcessor converters.
 * 
 * Class itself perform identical transformation.
 */
template<class T>
class EventProcessorTransform: public EventProcessor<T>
{
public:
    EventProcessorTransform(EventProcessor<T>* eventProcessor):
        eventProcessor(eventProcessor) {}
    
    ~EventProcessorTransform() {delete eventProcessor;}
    
    void processFunctionEntry(ThreadInfo<T>* thread,
        Addr<T> func)
    {
        eventProcessor->processFunctionEntry(thread, func);
    }
    void processFunctionExit(ThreadInfo<T>* thread,
        Addr<T> func)
    {
        eventProcessor->processFunctionExit(thread, func);
    }
    void processCallPre(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> func)
    {
        eventProcessor->processCallPre(thread, pc, func);
    }
    void processCallPost(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> func)
    {
        eventProcessor->processCallPost(thread, pc, func);
    }
    void processMAStart(ThreadInfo<T>* thread, int nEvents)
    {
        eventProcessor->processMAStart(thread, nEvents);
    }
    
    void processMA(ThreadInfo<T>* thread, Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        eventProcessor->processMA(thread, pc, addr, size, type);
    }
    void processLMAUpdate(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size)
    {
        eventProcessor->processLMAUpdate(thread, pc, addr, size);
    }
    void processLMARead(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size)
    {
        eventProcessor->processLMARead(thread, pc, addr, size);
    }
    void processLMAWrite(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size)
    {
        eventProcessor->processLMAWrite(thread, pc, addr, size);
    }
    void processIOMA(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        eventProcessor->processIOMA(thread, pc, addr, size, type);
    }
    void processMRB(ThreadInfo<T>* thread, Addr<T> pc)
    {
        eventProcessor->processMRB(thread, pc);
    }
    void processMWB(ThreadInfo<T>* thread, Addr<T> pc)
    {
        eventProcessor->processMWB(thread, pc);
    }
    void processMFB(ThreadInfo<T>* thread, Addr<T> pc)
    {
        eventProcessor->processMFB(thread, pc);
    }
    void processAlloc(ThreadInfo<T>* thread,
        Addr<T> pc, Size<T> size, Addr<T> pointer)
    {
        eventProcessor->processAlloc(thread, pc, size, pointer);
    }
    void processFree(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> pointer)
    {
        eventProcessor->processFree(thread, pc, pointer);
    }
    void processLock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj, enum kedr_lock_type type)
    {
        eventProcessor->processLock(thread, pc, obj, type);
    }
    void processUnlock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj, enum kedr_lock_type type)
    {
        eventProcessor->processUnlock(thread, pc, obj, type);
    }
    void processRLock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj, enum kedr_lock_type type)
    {
        eventProcessor->processRLock(thread, pc, obj, type);
    }
    void processRUnlock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj, enum kedr_lock_type type)
    {
        eventProcessor->processRUnlock(thread, pc, obj, type);
    }
    void processSignal(ThreadInfo<T>* thread, Addr<T> pc,
        Addr<T> obj, enum kedr_sw_object_type type)
    {
        eventProcessor->processSignal(thread, pc, obj, type);
    }
    void processWait(ThreadInfo<T>* thread, Addr<T> pc,
        Addr<T> obj, enum kedr_sw_object_type type)
    {
        eventProcessor->processWait(thread, pc, obj, type);
    }
    void processThreadCreateBefore(ThreadInfo<T>* thread,
        Addr<T> pc)
    {
        eventProcessor->processThreadCreateBefore(thread, pc);
    }
    void processThreadCreateAfter(ThreadInfo<T>* thread,
        Addr<T> pc, ThreadInfo<T>* childThread)
    {
        eventProcessor->processThreadCreateAfter(thread, pc, childThread);
    }

    void processThreadJoin(ThreadInfo<T>* thread,
        Addr<T> pc, ThreadInfo<T>* childThread)
    {
        eventProcessor->processThreadJoin(thread, pc, childThread);
    }
    
    void processThreadStart(ThreadInfo<T>* thread,
        ThreadInfo<T>* parentThread)
    {
        eventProcessor->processThreadStart(thread, parentThread);
    }
    void processThreadStop(ThreadInfo<T>* thread)
    {
        eventProcessor->processThreadStop(thread);
    }

protected:
    EventProcessor<T>* eventProcessor;
};

/********************** Converter for restore PC***********************/
/* 
 * EventProcessor -> EventProcessor converter which restore PC in
 * global function models.
 */
template<class T>
class EventProcessorRestorePC: public EventProcessorTransform<T>
{
public:
    EventProcessorRestorePC(EventProcessor<T>* eventProcessor):
        EventProcessorTransform<T>(eventProcessor) {}

    void processCallPre(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> func)
    {
        thread->callAddr = pc;
        EventProcessorTransform<T>::processCallPre(thread, pc, func);
    }
    void processCallPost(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> func)
    {
        EventProcessorTransform<T>::processCallPost(thread, pc, func);
        thread->callAddr = 0;
    }
#define RESTORE_PC if(pc == 0) pc = thread->callAddr

    void processMA(ThreadInfo<T>* thread, Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processMA(thread, pc, addr, size, type);
    }
    void processLMAUpdate(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processLMAUpdate(thread, pc, addr, size);
    }
    void processLMARead(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processLMARead(thread, pc, addr, size);
    }
    void processLMAWrite(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processLMAWrite(thread, pc, addr, size);
    }
    void processIOMA(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processIOMA(thread, pc, addr, size, type);
    }
    void processMRB(ThreadInfo<T>* thread, Addr<T> pc)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processMRB(thread, pc);
    }
    void processMWB(ThreadInfo<T>* thread, Addr<T> pc)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processMWB(thread, pc);
    }
    void processMFB(ThreadInfo<T>* thread, Addr<T> pc)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processMFB(thread, pc);
    }
    void processAlloc(ThreadInfo<T>* thread,
        Addr<T> pc, Size<T> size, Addr<T> pointer)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processAlloc(thread, pc, size, pointer);
    }
    void processFree(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> pointer)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processFree(thread, pc, pointer);
    }
    void processLock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj, enum kedr_lock_type type)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processLock(thread, pc, obj, type);
    }
    void processUnlock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj, enum kedr_lock_type type)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processUnlock(thread, pc, obj, type);
    }
    void processRLock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj, enum kedr_lock_type type)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processRLock(thread, pc, obj, type);
    }
    void processRUnlock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj, enum kedr_lock_type type)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processRUnlock(thread, pc, obj, type);
    }
    void processSignal(ThreadInfo<T>* thread, Addr<T> pc,
        Addr<T> obj, enum kedr_sw_object_type type)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processSignal(thread, pc, obj, type);
    }
    void processWait(ThreadInfo<T>* thread, Addr<T> pc,
        Addr<T> obj, enum kedr_sw_object_type type)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processWait(thread, pc, obj, type);
    }
    void processThreadCreateBefore(ThreadInfo<T>* thread,
        Addr<T> pc)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processThreadCreateBefore(thread, pc);
    }
    void processThreadCreateAfter(ThreadInfo<T>* thread,
        Addr<T> pc, ThreadInfo<T>* childThread)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processThreadCreateAfter(thread, pc, childThread);
    }

    void processThreadJoin(ThreadInfo<T>* thread,
        Addr<T> pc, ThreadInfo<T>* childThread)
    {
        RESTORE_PC;
        EventProcessorTransform<T>::processThreadJoin(thread, pc, childThread);
    }
};

/************************ Section record ******************************/
/* Representation of one record in 'sections' file */
struct SectionRecord
{
    uint64_t addr;
    string name;
    
    SectionRecord(uint64_t addr, const string& name):
        addr(addr), name(name) {}
};

/* Extract records from 'sections' file */
vector<SectionRecord> loadSectionRecords(const char* sectionsFile)
{
    vector<SectionRecord> sectionRecords;
    
    FILE* f = fopen(sectionsFile, "r");
    if(f == NULL)
    {
        perror("Failed to open file with sections");
        throw runtime_error("Failed to open file with sections");
    }
    
    char* line = NULL;
    size_t alloc_size;
    ssize_t len;
    int lineno = 1;
    
    for(len = getline(&line, &alloc_size, f);
        len > 0;
        len = getline(&line, &alloc_size, f), ++lineno)
    {
        /* Discard newline character */
        if(line[len - 1] == '\n') line[len - 1] = '\0';

        char* current = line;
        /* Skip initial spaces */
        while(isspace(*current)) current++;
        
        if(*current == '\0') continue;/* Line is empty */
        
        /* Read address */
        errno = 0;
        unsigned long long addr = strtoull(current, &current, 16);
        if(errno)
        {
            fprintf(stderr, "Failed to parse address in sections file "
                "at line %d\n", lineno);
            free(line);
            fclose(f);
            throw logic_error("Failed to parse sections file");
        }
        /* Skip spaces between address and section name */
        while(isspace(*current)) current++;
        /* Rest is a section name */
        sectionRecords.push_back(SectionRecord(addr, current));
    }
    free(line);
    fclose(f);
    
    return sectionRecords;
}


/************************** Sections mapping **************************/

/* Additional types */
template<class T>
struct AddrRange
{
    T start;
    T end;
    
    AddrRange(T start, T end) : start(start), end(end) {}
    AddrRange(T value) : start(value), end(value + 1) {}
    
    bool operator<(const AddrRange& AddrRange) const {return end <= AddrRange.start;}
};

/* 
 * Determine whether section contain code, which is mapped
 * into memory when module is loaded.
 */
static inline bool isCodeScn(const GElf_Shdr& shdr)
{
    if(!(shdr.sh_flags & SHF_ALLOC)) return false;
    if(!(shdr.sh_flags & SHF_EXECINSTR)) return false;
    if(shdr.sh_size <= 0) return false;

    return true;
}

/* 
 * Return mapping of code sections into memory.
 * 
 * Key of the resulted map is AddrRange of addresses, value is an index of
 * the section in ELF file.
 */
template<class T>
map<AddrRange<T>, int> getCodeSectionsMapping(Elf* e,
    const vector<SectionRecord>& sectionRecords)
{
    map<AddrRange<T>, int> sectionsMapping;
    
    size_t shdrstrndx;
    elf_getshdrstrndx(e, &shdrstrndx);

    size_t nSections;
    elf_getshdrnum(e, &nSections);
    
    for(int i = 0; i < (int)nSections; i++)
    {
        Elf_Scn* scn = elf_getscn(e, i);
        
        GElf_Shdr shdr;
        gelf_getshdr(scn, &shdr);
        
        if(!isCodeScn(shdr)) continue;
        
        const char* scn_name = elf_strptr(e, shdrstrndx, shdr.sh_name);
        if((scn_name == NULL) || (*scn_name == '\0')) continue;
        
        for(int j = 0; j < (int)sectionRecords.size(); j++)
        {
            const SectionRecord& sectionRecord = sectionRecords[j];
            if(sectionRecord.name == scn_name)
            {
                T start = sectionRecord.addr;
                T end = start + shdr.sh_size;
                sectionsMapping.insert(
                    make_pair(AddrRange<T>(start, end), i));
                break;
            }
        }
    }
    
    return sectionsMapping;
}

/************** Converter to tsan with resolving PCs ******************/
/* 
 * Prepend each event in tsan trace with commentaries about pc
 * originated.
 */

template<class T>
class EventProcessorTsanPC: public EventProcessorTsan<T>
{
public:
    EventProcessorTsanPC(ostream& os,
        const map<AddrRange<T>, string>& sections)
        : EventProcessorTsan<T>(os), sections(sections) {}

    void processCallPre(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> func)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processCallPre(thread, pc, func);
    }

    void processMA(ThreadInfo<T>* thread, Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processMA(thread, pc, addr, size, type);
    }

    virtual void processIOMA(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processIOMA(thread, pc, addr, size, type);
    }

    void processAlloc(ThreadInfo<T>* thread,
        Addr<T> pc, Size<T> size, Addr<T> pointer)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processAlloc(thread, pc, size, pointer);
    }
    void processFree(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> pointer)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processFree(thread, pc, pointer);
    }

    void processLock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj,
        enum kedr_lock_type type)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processLock(thread, pc, obj, type);
    }
    void processUnlock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj,
        enum kedr_lock_type type)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processUnlock(thread, pc, obj, type);
    }
    void processRLock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj,
        enum kedr_lock_type type)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processRLock(thread, pc, obj, type);
    }
    void processRUnlock(ThreadInfo<T>* thread,
        Addr<T> pc, Addr<T> obj,
        enum kedr_lock_type type)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processRUnlock(thread, pc, obj, type);
    }
    void processSignal(ThreadInfo<T>* thread, Addr<T> pc,
        Addr<T> obj, enum kedr_sw_object_type type)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processSignal(thread, pc, obj, type);
    }
    void processWait(ThreadInfo<T>* thread, Addr<T> pc,
        Addr<T> obj, enum kedr_sw_object_type type)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processWait(thread, pc, obj, type);
    }
    void processThreadCreateBefore(ThreadInfo<T>* thread,
        Addr<T> pc)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processThreadCreateBefore(thread, pc);
    }
    void processThreadCreateAfter(ThreadInfo<T>* thread,
        Addr<T> pc , ThreadInfo<T>* childThread)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processThreadCreateAfter(thread, pc, childThread);
    }
    void processThreadJoin(ThreadInfo<T>* thread,
        Addr<T> pc, ThreadInfo<T>* childThread)
    {
        printPCInfo(pc);
        EventProcessorTsan<T>::processThreadJoin(thread, pc, childThread);
    }
    
private:
    map<AddrRange<T>, string> sections;
    
    void printPCInfo(Addr<T> pc);
};

template<class T>
void EventProcessorTsanPC<T>::printPCInfo(Addr<T> pc)
{
    typename map<AddrRange<T>, string>::const_iterator iter = sections.find(pc.addr);
    if(iter != sections.end())
    {
        T offset = pc - iter->first.start;
        TsanEventPrinter<T>::commentBegin() <<  pc << ":"
            << iter->second << "+0x" << Addr<T>(offset);
        TsanEventPrinter<T>::commentEnd();
    }
}


/************** Fix lock prefixes in events ***************************/
/* 
 * For all memory access events check fist byte of instruction
 * (to which PC points). If first byte is f0 ('lock' prefix), then event
 * is treated as locked memory access.
 */

template<class T>
class EventProcessorFixLock: public EventProcessorTransform<T>
{
public:
    EventProcessorFixLock(EventProcessor<T>* eventProcessor,
        const char* moduleFile, const vector<SectionRecord>& sectionRecords);
    ~EventProcessorFixLock();
    
    void processMA(ThreadInfo<T>* thread, Addr<T> pc, Addr<T> addr, Size<T> size,
        enum kedr_memory_event_type type)
    {
        if(isLockPrefix(pc))
        {
            switch(type)
            {
            case KEDR_ET_MREAD:
                EventProcessorTransform<T>::processLMARead(thread, pc, addr, size);
            break;
            case KEDR_ET_MWRITE:
                EventProcessorTransform<T>::processLMAWrite(thread, pc, addr, size);
            break;
            case KEDR_ET_MUPDATE:
                EventProcessorTransform<T>::processLMAUpdate(thread, pc, addr, size);
            break;
            }
//#ifdef KEDR_DEBUG
            cerr << "Memory access at " << pc
                << " has been transformed into locked access." << endl;
//#endif
        }
        else
        {
            EventProcessorTransform<T>::processMA(thread, pc, addr, size, type);
        }
    }
private:
    int fd;
    Elf* e;
    
    map<AddrRange<T>, const unsigned char*> sectionDataMap;
    
    bool isLockPrefix(Addr<T> addr);
    
    ThreadInfo<T>* threadMA;
};

template<class T>
bool EventProcessorFixLock<T>::isLockPrefix(Addr<T> addr)
{
    typename map<AddrRange<T>, const unsigned char*>::const_iterator iter
        = sectionDataMap.find(AddrRange<T>(addr.addr));
    if(iter != sectionDataMap.end())
    {
        T offset = addr - iter->first.start;
        const unsigned char* data = iter->second;
        
        if(data[offset] == 0xf0) return true;
    }
    return false;
}

template<class T>
EventProcessorFixLock<T>::EventProcessorFixLock(
    EventProcessor<T> *eventProcessor,
    const char* moduleFile,
    const vector<SectionRecord>& sectionRecords)
        : EventProcessorTransform<T>(eventProcessor)
{
    /* Open module file as ELF */
    if(elf_version(EV_CURRENT) == EV_NONE)
    {
        throw runtime_error("Libelf initialization failed");
    }
    
    fd = open(moduleFile, O_RDONLY);
    if(fd == -1)
    {
        cerr << "Failed to open file '" << moduleFile << "': "
            << strerror(errno) << "." << endl;
        throw runtime_error("Failed to open module file.");
    }
    
    e = elf_begin(fd, ELF_C_READ, NULL);
    if(e == NULL)
    {
        close(fd);
        throw runtime_error("elf_begin() failed");
    }
    
    if(elf_kind(e) != ELF_K_ELF)
    {
        close(fd);
        throw runtime_error("Not an ELF");
    }
    
    try
    {
        /* Determine sections mapping usign section records */
        map<AddrRange<T>, int> sectionsMapping
            = getCodeSectionsMapping<T>(e, sectionRecords);
        
        /* For each section in mapping extract data for that section. */
        for(typename map<AddrRange<T>, int>::const_iterator iter = sectionsMapping.begin();
            iter != sectionsMapping.end();
            ++iter)
        {
            Elf_Scn* scn = elf_getscn(e, iter->second);
            assert(scn);
            Elf_Data* data = elf_rawdata(scn, NULL);
            if(data == NULL)
            {
                GElf_Shdr shdr;
                gelf_getshdr(scn, &shdr);
                size_t shdrstrndx;
                elf_getshdrstrndx(e, &shdrstrndx);
                
                cerr << "Failed to extract data for section '"
                    << elf_strptr(e, shdrstrndx, shdr.sh_name) << "'." << endl;
                
                throw runtime_error("Failed to extract data for module section.");
            }
            
            sectionDataMap.insert(make_pair(iter->first, (const unsigned char*)data->d_buf));
        }
    }
    catch(exception&)
    {
        elf_end(e);
        close(fd);
        
        throw;
    }
}

template<class T>
EventProcessorFixLock<T>::~EventProcessorFixLock(void)
{
    elf_end(e);
    close(fd);
}

/****************************** Options *******************************/
/* Representation of program's options */
struct Options
{
    string traceDir;     /* Required */
    string sectionsFile; /* "" if is not set */
    string moduleFile;   /* "" if is not set */
    
    bool resolvePC;/* Whether need to resolve program counters */
    
    bool fixLock; /* Whether need to restore 'lock' operation prefix.*/
    
    Options(void) : traceDir(""), sectionsFile(""), moduleFile(""),
        resolvePC(false), fixLock(false) {}
    
    int parseParameters(int argc, char** argv);
    
    static void usage(void);
};

int Options::parseParameters(int argc, char** argv)
{
    enum OptID
    {
        optTraceDir = 1,/* This value will be returned when argument is not an option */
        optInvalidOption = '?',
        optMissingArgument = ':',
        
        optHelp  = 'h',
        
        optSectionsFile = 'S',
        optModuleFile = 'm',
        
        optFixLock = 256,
        optResolvePC,
        optFixAll,
    };

    // Available program's options
    static const char short_options[] = "-:hS:m:";
    static struct option long_options[] = {
        {"sections", 1, 0, optSectionsFile},
        {"module", 1, 0, optModuleFile},
        {"fix-lock", 0, 0, optFixLock},
        {"fix-all", 0, 0, optFixAll},
        {"resolve-pc", 0, 0, optResolvePC},
        {"help", 0, 0, optHelp},
        {0, 0, 0, 0}
    };
    int opt;

    for(opt = getopt_long(argc, argv, short_options, long_options, NULL);
        opt != -1;
        opt = getopt_long(argc, argv, short_options, long_options, NULL))
    {
        switch((OptID)opt)
        {
        case optInvalidOption:
            if(optind < argc)
            {
                cerr << "Unrecognized option: " << argv[optind] << endl;
            }
            return -1;
        break;
        case optMissingArgument:
            cerr << "Miss argument for option " << optopt << endl;
            return -1;
        break;
        case optSectionsFile:
            if(sectionsFile != "")
            {
                cerr << "Sections file has been issued more than once.\n";
                return -1;
            }
            sectionsFile = optarg;
        break;
        case optModuleFile:
            if(moduleFile != "")
            {
                cerr << "Module file has been issued more than once.\n";
                return -1;
            }
            moduleFile = optarg;
        break;
        case optTraceDir:
            if(traceDir != "")
            {
                cerr << "Trace directory has been issued more than once.\n";
                return -1;
            }
            traceDir = optarg;
        break;
        case optFixAll:
        case optFixLock:
            fixLock = true;
        break;
        case optResolvePC:
            resolvePC = true;
        break;
        case optHelp:
            usage();
            return 1;
        break;
        default:
            return -1;
        break;
        }
    }
    /* Trace directory has been processed as option with code 1. */
    if(traceDir == "")
    {
        cerr << "Trace directory parameter is required.\n";
        return -1;
    }
    
    if(fixLock)
    {
        if(sectionsFile == "")
        {
            cerr << "Sections file is required for fix lock prefixes.\n";
            return -1;
        }
        if(moduleFile == "")
        {
            cerr << "Module file is required for fix lock prefixes.\n";
            return -1;
        }

    }
    
    if(resolvePC)
    {
        if(sectionsFile == "")
        {
            cerr << "Sections file is required for PC resolving.\n";
            return -1;
        }
        if(moduleFile == "")
        {
            cerr << "Module file is required for PC resolving.\n";
            return -1;
        }

    }
    
    return 0;
}

extern char _binary_converter_usage_start[];
extern char _binary_converter_usage_end[];

void Options::usage(void)
{
    (void)fwrite(_binary_converter_usage_start,
        _binary_converter_usage_end - _binary_converter_usage_start,
        1,
        stderr);
}

/****************************** MAIN **********************************/
/* 
 * Create event processor corresponded to trace reader, created
 * for traceDir, and options.
 */
template<class T>
KEDREventProcessor* createEventProcessor(const KEDRTraceReader& traceReader,
    const Options& options)
{
    EventProcessor<T>* eventProcessorIntermediate;
    
    if(options.resolvePC)
    {
        /* Open module file as ELF */
        if(elf_version(EV_CURRENT) == EV_NONE)
        {
            throw runtime_error("Libelf initialization failed");
        }
        
        int fd = open(options.moduleFile.c_str(), O_RDONLY);
        if(fd == -1)
        {
            cerr << "Failed to open file '" << options.moduleFile << "': "
                << strerror(errno) << "." << endl;
            throw runtime_error("Failed to open module file.");
        }
        
        Elf* e = elf_begin(fd, ELF_C_READ, NULL);
        if(e == NULL)
        {
            close(fd);
            throw runtime_error("elf_begin() failed");
        }
        
        if(elf_kind(e) != ELF_K_ELF)
        {
            close(fd);
            throw runtime_error("Not an ELF");
        }
        /* Determine sections mapping usign sections file */
        map<AddrRange<T>, int> sectionsMapping
            = getCodeSectionsMapping<T>(e,
                loadSectionRecords(options.sectionsFile.c_str()));
        
        /* Same mapping, but use section names instead of indices */
        map<AddrRange<T>, string> sectionsMappingNames;
        
        typename map<AddrRange<T>, int>::const_iterator iter = sectionsMapping.begin();
        typename map<AddrRange<T>, int>::const_iterator iter_end = sectionsMapping.end();
        
        size_t shdrstrndx;
        elf_getshdrstrndx(e, &shdrstrndx);

        for(;iter != iter_end; ++iter)
        {
            Elf_Scn* scn = elf_getscn(e, iter->second);
        
            GElf_Shdr shdr;
            gelf_getshdr(scn, &shdr);
            
            const char* scn_name = elf_strptr(e, shdrstrndx, shdr.sh_name);
            
            sectionsMappingNames.insert(make_pair(iter->first, string(scn_name)));
        }
        
        elf_end(e);
        close(fd);
        /* Create tsan processor which resolve PC */
        eventProcessorIntermediate = new EventProcessorTsanPC<T>(cout,
            sectionsMappingNames);
    }
    else
    {
        /* Create tsan standard processor */
        eventProcessorIntermediate = new EventProcessorTsan<T>(cout);
    }
    
    /* Wraps tsan processor into PC-restoring processor */
    eventProcessorIntermediate = new EventProcessorRestorePC<T>(
        eventProcessorIntermediate);
    
    if(options.fixLock)
    {
        /* Additionally wraps into fix-locks transformator. */
        eventProcessorIntermediate = new EventProcessorFixLock<T>(
            eventProcessorIntermediate,
            options.moduleFile.c_str(),
            loadSectionRecords(options.sectionsFile.c_str()));
    }
    
    return new KEDREventProcessorStandard<T>(traceReader, eventProcessorIntermediate);
}



int main(int argc, char** argv)
{
    Options options;
    
    if(options.parseParameters(argc, argv) != 0) return 1;
    
    KEDRTraceReader traceReader(options.traceDir.c_str());
    
    KEDRTraceProcessor traceProcessor(traceReader);
    
    KEDREventProcessor* eventProcessor;
    
    const string* pointer_bits = traceReader.findParameter(
        "trace.pointer_bits");
    if(pointer_bits == NULL)
    {
        cerr << "Trace should have parameter 'trace.pointer_bits' "
            "defined, but it haven't\n";
        return 1;
    }
    else if(*pointer_bits == "32")
    {
        eventProcessor = createEventProcessor<uint32_t>(traceReader, options);
    }
    else if(*pointer_bits == "64")
    {
        eventProcessor = createEventProcessor<uint64_t>(traceReader, options);
    }
    else
    {
        cerr << "Unknown value of 'trace.pointer_bits' parameter: "
            << *pointer_bits << "\n";
        return 1;
    }
    
    traceProcessor.process(*eventProcessor);
    
    delete eventProcessor;
    
    return 0;
}