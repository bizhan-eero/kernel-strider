/* 
 * Convert trace generated by the KEDR into format which may be
 * processed by Thread Sanitizer.
 */

#include <kedr/kedr_trace_reader/kedr_trace_reader.h>

#include <kedr/object_types.h> /* Enumerations describing events */

#include <iostream>
#include <stdexcept>

#include <iomanip>

#include <vector>
#include <map>

/* Wrapper around addresses for template extracting and pretty printing */
template<class T>
struct Addr;

template<>
struct Addr<uint32_t>
{
    Addr(const CTFVarInt& var, CTFContext& context):
        addr(var.getUInt32(context)) {}
    
    bool operator<(const Addr<uint32_t>& addr) const {return this->addr < addr.addr;}
    
    operator uint32_t(void) const {return addr;}
    
    uint32_t addr;
};

template<>
struct Addr<uint64_t>
{
    Addr(const CTFVarInt& var, CTFContext& context):
        addr(var.getUInt64(context))
    {
        //debug
        if(!var.isExist(context))
        {
            std::cerr << "Variable " << var.name() << " doesnt't exist "
                "in given context.\n";
            throw std::logic_error("Read unexistent variable.\n");
        }
    }
    
    operator uint64_t(void) const {return addr;}
    
    uint64_t addr;
};


template<class T>
std::ostream& operator<<(std::ostream& os, const struct Addr<T>& addr)
{
    std::ios_base::fmtflags oldFlags = os.flags();
    
    os << std::hex << addr.addr;
    
    os.flags(oldFlags);
    
    return os;
}


/* Wrapper around addresses for template extracting and pretty printing */
template<class T>
struct Size;

template<>
struct Size<uint32_t>
{
    Size(const CTFVarInt& var, CTFContext& context):
        size(var.getUInt32(context))
    {
        //debug
        if(!var.isExist(context))
        {
            std::cerr << "Variable " << var.name() << " doesnt't exist "
                "in given context.\n";
            throw std::logic_error("Read unexistent variable.\n");
        }
    }

    
    uint32_t size;
};

template<>
struct Size<uint64_t>
{
    Size(const CTFVarInt& var, CTFContext& context):
        size(var.getUInt64(context)) {}
    
    uint64_t size;
};


template<class T>
std::ostream& operator<<(std::ostream& os, const struct Size<T>& size)
{
    std::ios_base::fmtflags oldFlags = os.flags();
    
    os << std::hex << size.size;
    
    os.flags(oldFlags);
    
    return os;
}

/* Wrapper around thread identificator for pretty printing */
struct Tid
{
    Tid(int tid): tid(tid){}
    
    Tid& operator=(const Tid& tid) {this->tid = tid.tid; return *this;}
    Tid& operator=(int tid) {this->tid = tid; return *this;}
    
    operator int(void) const {return tid;}
    
    int tid;
};

std::ostream& operator<<(std::ostream& os, const struct Tid& tid)
{
    std::ios_base::fmtflags oldFlags = os.flags();
    
    os << std::hex << tid.tid;
    
    os.flags(oldFlags);
    
    return os;
}


/* Helpers for search typed variables */
static const CTFVarInt& findInt(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find integer variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isInt())
    {
        std::cerr << "Variable with name '" << name << "' is not integer.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarInt*>(var);
}

static const CTFVarEnum& findEnum(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find enumeration variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isEnum())
    {
        std::cerr << "Variable with name '" << name << "' is not enumeration.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarEnum*>(var);
}

static const CTFVarArray& findArray(const CTFReader& reader, const std::string& name)
{
    const CTFVar* var = reader.findVar(name);
    if(var == NULL)
    {
        std::cerr << "Failed to find array-like variable '" << name << "'.\n";
        throw std::invalid_argument("Invalid variable name");
    }
    if(!var->isArray())
    {
        std::cerr << "Variable with name '" << name << "' is not array-like.\n";
        throw std::invalid_argument("Invalid variable type");
    }
    return *static_cast<const CTFVarArray*>(var);
}

class TsanEventBuilder;

/* 
 * Build trace for tsan in needed format.
 * 
 * 'T' means address integer type and may be uint32_t or uint64_t.
 */
template<class T>
class TsanTraceBuilder
{
public:
    TsanTraceBuilder(const KEDRTraceReader& traceReader);
    ~TsanTraceBuilder(void);
    /* Build trace into given stream */
    void build(std::ostream& os);

    /* Helpers for use in event builders */
    void registerThreadStart(Tid tid, Tid parentTid = 0) const
        {*os << "THR_START " << tid << " 0 0 " << parentTid << "\n";}
    void registerThreadEnd(Tid tid) const
        {*os << "THR_END " << tid << " 0 0 0\n";}
    void registerRead(Tid tid, Addr<T> pc, Addr<T> addr, Size<T> size) const
        {*os << "READ " << tid << " " << pc << " " << addr << " " << size << "\n";}
    void registerWrite(Tid tid, Addr<T> pc, Addr<T> addr, Size<T> size) const
        {*os << "WRITE " << tid << " " << pc << " " << addr << " " << size << "\n";}
    void registerSignal(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "SIGNAL " << tid << " " << pc << " " << obj << " 0\n";}
    void registerWait(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "WAIT " << tid << " " << pc << " " << obj << " 0\n";}
    void registerFunctionCall(Tid tid, Addr<T> pc, Addr<T>) const
        {*os << "RTN_CALL " << tid << " " << pc << " 0 0\n";}
    void registerFunctionExit(Tid tid, Addr<T>, Addr<T>) const
        {*os << "RTN_EXIT " << tid << " 0 0 0\n";}
    void registerLock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "WRITER_LOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void registerRLock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "READER_LOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void registerUnlock(Tid tid, Addr<T> pc, Addr<T> obj) const
        {*os << "UNLOCK " << tid << " " << pc << " " << obj << " 0\n";}
    void registerAlloc(Tid tid, Addr<T> pc, Addr<T> pointer, Size<T> size) const
        {*os << "MALLOC " << tid << " " << pc << " " << pointer << " " << size << "\n";}
    void registerFree(Tid tid, Addr<T> pc, Addr<T> pointer) const
        {*os << "FREE " << tid << " " << pc << " " << pointer << " 0\n";}
    void registerThreadCreateBefore(Tid tid, Addr<T> pc) const
        {*os << "THR_CREATE_BEFORE " << tid << " " << pc << " 0 0\n";}
    void registerThreadCreateAfter(Tid tid, Addr<T> pc, Tid childTid) const
        {(void)pc; *os << "THR_CREATE_AFTER " << tid << " 0 " << childTid << " 0\n";}
    void registerThreadJoin(Tid tid, Addr<T> pc, Tid childTid) const
        {*os << "THR_JOIN_AFTER " << tid << " " << pc << " " << childTid << " 0\n";}
    void registerBlock(Tid tid, Addr<T> pc) const
        {*os << "SBLOCK_ENTER " << tid << " " << pc << " 0 0\n";}

    const KEDRTraceReader& getTraceReader(void) const
        {return traceReader;}

    /* 
     * Return integer identificator of thread for given address.
     * If thread is not registered, return -1.
     */
    Tid getTid(Addr<T> taddr) const;
    /*
     * Register new integer identificator to thread of given address.
     */
    Tid newTid(Addr<T> taddr) const;
    /*
     * Unregister integer identificator to thread of given address.
     * 
     * May be called when it is known that thread is terminated.
     * 
     * NOTE: Same address may be encountered in the future. In that case
     * new index will be assigned for it. It is normal situation.
     */
    void deleteTid(Addr<T> taddr) const;

private:
    const KEDRTraceReader& traceReader;
    /* Builder for each index of event type enumeration. */
    std::vector<TsanEventBuilder*> eventBuilders;
    /* Map of registered threads */
    mutable std::map<Addr<T>, int> threads;
    /* first unused identificator for tid*/
    mutable int firstUnusedTid;
    
    void setupEventBuilders(void);
    
    const CTFVarEnum& eventTypeVar;
    /* Variable used in header printing */
    const CTFVarInt& tidVar;
    /* Output information about one event */
    void buildEvent(CTFReader::Event& event);
    
    std::ostream* os;
};

template<class T>
TsanTraceBuilder<T>::TsanTraceBuilder(const KEDRTraceReader& traceReader)
    : traceReader(traceReader),
    eventTypeVar(findEnum(traceReader, "stream.event.header.type")),
    tidVar(findInt(traceReader, "stream.event.context.tid"))
{
    setupEventBuilders();
}

/* Abstract class which process event of concrete type */
class TsanEventBuilder
{
public:
    virtual ~TsanEventBuilder() {}
    
    virtual void build(const KEDRTraceReader::EventIterator& iter, Tid tid) = 0;
};

template<class T>
TsanTraceBuilder<T>::~TsanTraceBuilder(void)
{
    for(int i = 0; i < (int)eventBuilders.size(); i++)
        delete eventBuilders[i];
}

template<class T>
void TsanTraceBuilder<T>::build(std::ostream& os)
{
    this->os = &os;
    
    threads.clear();
    firstUnusedTid = 0;
    
    for(KEDRTraceReader::EventIterator iter(traceReader);
        iter;
        ++iter)
    {
        Addr<T> tidAddr(tidVar, *iter);
        Tid tid = getTid(tidAddr);
        if(tid == -1)
        {
            tid = newTid(tidAddr);
            registerThreadStart(tid);
        }
       
        int index = eventTypeVar.getValue(*iter);
        eventBuilders[index]->build(iter, tid);
    }
    
    threads.clear();
    this->os = NULL;
}

template<class T>
Tid TsanTraceBuilder<T>::getTid(Addr<T> addr) const
{
    typename std::map<Addr<T>, int>::const_iterator iter = threads.find(addr);
    return (iter != threads.end()) ? iter->second : -1;
}

template<class T>
void TsanTraceBuilder<T>::deleteTid(Addr<T> addr) const
{
    threads.erase(addr);
}


template<class T>
Tid TsanTraceBuilder<T>::newTid(Addr<T> addr) const
{
    threads.insert(std::make_pair(addr, firstUnusedTid));
    return firstUnusedTid++;
}

/* Concrete specializations of the class */

/* Ignore event(event doesn't affect on Tsan)*/
class TsanEventBuilderIgnore: public TsanEventBuilder
{
public:
    void build(const KEDRTraceReader::EventIterator&, Tid) {}
};


/* Unknown event type (for intermediate implementation). */
template<class T>
class TsanEventBuilderUnknown: public TsanEventBuilder
{
public:
    TsanEventBuilderUnknown(const TsanTraceBuilder<T>& eventBuilder):
        eventTypeVar(findEnum(eventBuilder.getTraceReader(),
            "stream.event.header.type")) {}
    
    void build(const KEDRTraceReader::EventIterator& iter, Tid)
    {
        std::string typeStr = eventTypeVar.getEnum(*iter);
        if(typeStr == "") typeStr = "(undefined)";
        
        std::cerr << "Unknown event type: '" << typeStr << "'\n";
    }
private:
    const CTFVarEnum& eventTypeVar;
};

/* Function entry/exit are ignored */

/* Function call pre */
template<class T>
class TsanEventBuilderFunctionCallPre: public TsanEventBuilder
{
public:
    TsanEventBuilderFunctionCallPre(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.fcpre.pc")),
        funcAddrVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.fcpre.func"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        traceBuilder.registerFunctionCall(tid,
            Addr<T>(pcVar, *iter), Addr<T>(funcAddrVar, *iter));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& funcAddrVar;
};

/* Function call post */
template<class T>
class TsanEventBuilderFunctionCallPost: public TsanEventBuilder
{
public:
    TsanEventBuilderFunctionCallPost(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.fcpost.pc")),
        funcAddrVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.fcpost.func"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        traceBuilder.registerFunctionExit(tid,
            Addr<T>(pcVar, *iter), Addr<T>(funcAddrVar, *iter));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& funcAddrVar;
};

/* Memory accesses */
template<class T>
class TsanEventBuilderMA: public TsanEventBuilder
{
public:
    TsanEventBuilderMA(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        accessesVar(findArray(traceBuilder.getTraceReader(), "event.fields.ma")),
        pcVar(findInt(traceBuilder.getTraceReader(), "event.fields.ma[].pc")),
        addrVar(findInt(traceBuilder.getTraceReader(), "event.fields.ma[].addr")),
        sizeVar(findInt(traceBuilder.getTraceReader(), "event.fields.ma[].size")),
        accessTypeVar(findInt(traceBuilder.getTraceReader(), "event.fields.ma[].access_type"))
        {}
    
    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        bool isFirst = true;
        for(CTFVarArray::ElemIterator elemIter(accessesVar, *iter);
            elemIter;
            ++elemIter)
        {
            if(isFirst)
            {
                traceBuilder.registerBlock(tid, Addr<T>(pcVar, *elemIter));
                isFirst = false;
            }
            buildOne(*elemIter, tid);
        }
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;

    const CTFVarArray& accessesVar;
    
    const CTFVarInt& pcVar;
    const CTFVarInt& addrVar;
    const CTFVarInt& sizeVar;
    const CTFVarInt& accessTypeVar;
    
    void buildOne(CTFContext& subevent, Tid tid)
    {
        int accessType = accessTypeVar.getInt32(subevent);
        Addr<T> pc(pcVar, subevent);
        Addr<T> addr(addrVar, subevent);
        Size<T> size(sizeVar, subevent);
        switch((enum kedr_memory_event_type)accessType)
        {
        case KEDR_ET_MREAD:
            traceBuilder.registerRead(tid, pc, addr, size);
        break;
        case KEDR_ET_MWRITE:
        case KEDR_ET_MUPDATE:
            traceBuilder.registerWrite(tid, pc, addr, size);
        break;
        default:
            std::cerr << "Unknown memory access operation.\n";
        }
    }
};

/* Locked operations are ignored */

/* IO operations */
template<class T>
class TsanEventBuilderIOMA: public TsanEventBuilder
{
public:
    TsanEventBuilderIOMA(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.ioma.pc")),
        addrVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.ioma.addr")),
        sizeVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.ioma.size")),
        accessTypeVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.ioma.access_type"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        int accessType = accessTypeVar.getUInt32(*iter);
        Addr<T> pc(pcVar, *iter);
        Addr<T> addr(addrVar, *iter);
        Size<T> size(sizeVar, *iter);
        
        switch((enum kedr_memory_event_type)accessType)
        {
        case KEDR_ET_MREAD:
            traceBuilder.registerRead(tid, pc, addr, size);
        break;
        case KEDR_ET_MWRITE:
        case KEDR_ET_MUPDATE:
            traceBuilder.registerWrite(tid, pc, addr, size);
        break;
        default:
            std::cerr << "Unknown memory access operation.\n";
        }
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& addrVar;
    const CTFVarInt& sizeVar;
    const CTFVarInt& accessTypeVar;
};

/* Barrier operations are ignored */

/* Alloc */
template<class T>
class TsanEventBuilderAlloc: public TsanEventBuilder
{
public:
    TsanEventBuilderAlloc(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.alloc.pc")),
        pointerVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.alloc.pointer")),
        sizeVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.alloc.size"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        Addr<T> pc(pcVar, *iter);
        Addr<T> pointer(pointerVar, *iter);
        Size<T> size(sizeVar, *iter);
        
        traceBuilder.registerAlloc(tid, pc, pointer, size);
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& pointerVar;
    const CTFVarInt& sizeVar;
};


/* Free */
template<class T>
class TsanEventBuilderFree: public TsanEventBuilder
{
public:
    TsanEventBuilderFree(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.free.pc")),
        pointerVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.free.pointer"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        Addr<T> pc(pcVar, *iter);
        Addr<T> pointer(pointerVar, *iter);
        
        traceBuilder.registerFree(tid, pc, pointer);
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& pointerVar;
};

/* Lock */
template<class T>
class TsanEventBuilderLock: public TsanEventBuilder
{
public:
    TsanEventBuilderLock(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.lock.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.lock.object"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        traceBuilder.registerLock(tid, Addr<T>(pcVar, *iter),
            Addr<T>(objectVar, *iter));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};

/* Unlock */
template<class T>
class TsanEventBuilderUnlock: public TsanEventBuilder
{
public:
    TsanEventBuilderUnlock(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.unlock.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.unlock.object"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        traceBuilder.registerUnlock(tid, Addr<T>(pcVar, *iter),
            Addr<T>(objectVar, *iter));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};


/* Read lock */
template<class T>
class TsanEventBuilderRLock: public TsanEventBuilder
{
public:
    TsanEventBuilderRLock(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.rlock.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.rlock.object"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        traceBuilder.registerRLock(tid, Addr<T>(pcVar, *iter),
            Addr<T>(objectVar, *iter));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};

/* Read unlock */
template<class T>
class TsanEventBuilderRUnlock: public TsanEventBuilder
{
public:
    TsanEventBuilderRUnlock(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.runlock.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.runlock.object"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        traceBuilder.registerUnlock(tid, Addr<T>(pcVar, *iter),
            Addr<T>(objectVar, *iter));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};

/* Signal */
template<class T>
class TsanEventBuilderSignal: public TsanEventBuilder
{
public:
    TsanEventBuilderSignal(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.signal.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.signal.object"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        traceBuilder.registerSignal(tid, Addr<T>(pcVar, *iter),
            Addr<T>(objectVar, *iter));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};

/* Wait */
template<class T>
class TsanEventBuilderWait: public TsanEventBuilder
{
public:
    TsanEventBuilderWait(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.wait.pc")),
        objectVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.wait.object"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        traceBuilder.registerWait(tid, Addr<T>(pcVar, *iter),
            Addr<T>(objectVar, *iter));
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& objectVar;
};


/* Thread create before */
template<class T>
class TsanEventBuilderTCreateBefore: public TsanEventBuilder
{
public:
    TsanEventBuilderTCreateBefore(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.tcreate_before.pc")),
        eventTypeVar(findEnum(traceBuilder.getTraceReader(),
            "stream.event.header.type")),
        tidVar(findInt(traceBuilder.getTraceReader(),
            "stream.event.context.tid")),
        childTidVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.tcreate_after.child_tid"))
    {
        /* 
         * Determine index of event type enumeration corresponded to
         * 'tcreate_after'.
         */
        const CTFTypeEnum& eventTypeType = *eventTypeVar.getType();
        int nEventTypes = eventTypeType.getNValues();
        for(int i = 1; i < nEventTypes; i++)
        {
            if(eventTypeType.valueToStr(i) == "tcreate_after")
            {
                tcreateAfterValue = i;
                return;
            }
        }
        throw std::logic_error("Cannot find event type 'tcreate_after'");
    }

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        Addr<T> tidReal(tidVar, *iter);
        /* Search nearest "tcreate_after" event in same thread */
        KEDRTraceReader::EventIterator iterAfter = iter.clone();
        for(++iterAfter; iterAfter; ++iterAfter)
        {
            if(Addr<T>(tidVar, *iterAfter) != tidReal)
                continue; /* Not our tid */
            if(eventTypeVar.getValue(*iterAfter) != tcreateAfterValue)
                continue; /* Not a 'tcreate_after' */
            break;
        }
        if(!iterAfter)
        {
            throw std::logic_error("'tcreate_before' event without 'tcreate_after'");
        }
        
        Addr<T> childTidReal(childTidVar, *iterAfter);
        if(childTidReal == 0) return;/* Thread creation canceled. */
        
        Tid childTid = traceBuilder.getTid(childTidReal);
        if(childTid == -1)
        {
            /* 
             * Thread with given address is created first time.
             * 
             * This situation is normal.
             */
            childTid = traceBuilder.newTid(childTidReal);
        }
        else
        {
            /*
             * Thread id is reused.
             * 
             * Explicitely terminate previous thread and assign another
             * id for new one(Thread Sanitizer cannot reuse id).
             */
            traceBuilder.registerThreadEnd(childTid);
            traceBuilder.deleteTid(childTidReal);
            childTid = traceBuilder.newTid(childTidReal);
        }
        /* Register event */
        traceBuilder.registerThreadCreateBefore(tid,
            Addr<T>(pcVar, *iter));
        /* Explicitely start child thread, 'as if' it is started now. */
        traceBuilder.registerThreadStart(childTid, tid);
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    /* For search event of particular type */
    const CTFVarEnum& eventTypeVar;
    /* Event type value corresponded to 'tcreate_after'*/
    int tcreateAfterValue;
    
    /* Extract own tid and compare it with others */
    const CTFVarInt& tidVar;

    const CTFVarInt& childTidVar;
};


/* Thread create after */
template<class T>
class TsanEventBuilderTCreateAfter: public TsanEventBuilder
{
public:
    TsanEventBuilderTCreateAfter(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.tcreate_after.pc")),
        childTidVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.tcreate_after.child_tid"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        /* 
         * Really, this event itself doesn't produce sync relation,
         * but Thread Sanitizer needs it.
         * 
         * Information from this event is already used in 'tcreate_before'.
         */
        
        Addr<T> childTidReal(childTidVar, *iter);
        if(childTidReal == 0)
            return;/* Event is really report about error in thread starting. */

        Tid childTid = traceBuilder.getTid(childTidReal);
        if(childTid == -1)
        {
            std::cerr << "WARNING: Child thread id isn't registered "
                << "before tcreate_after event. It is error for given converter.";
            /* Do not terminate conversion. */
            childTid = traceBuilder.newTid(childTidReal);
        }
        
        traceBuilder.registerThreadCreateAfter(tid, Addr<T>(pcVar, *iter),
            childTid);
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& childTidVar;
};

/* Thread join */
template<class T>
class TsanEventBuilderTJoin: public TsanEventBuilder
{
public:
    TsanEventBuilderTJoin(const TsanTraceBuilder<T>& traceBuilder):
        traceBuilder(traceBuilder),
        pcVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.tjoin.pc")),
        childTidVar(findInt(traceBuilder.getTraceReader(),
            "event.fields.tjoin.child_tid"))
        {}

    void build(const KEDRTraceReader::EventIterator& iter, Tid tid)
    {
        Addr<T> childTidReal(childTidVar, *iter);
        Tid childTid = traceBuilder.getTid(childTidReal);
        if(childTid == -1)
        {
            /* 
             * It is not an error for Linux kernel to join for the
             * thread which is not started.
             * 
             * Ignore event in that case.
             */
            return;
        }
        /* Stop thread explicitely */
        traceBuilder.registerThreadEnd(childTid);
        traceBuilder.registerThreadJoin(tid, Addr<T>(pcVar, *iter),
            childTid);
        /* Inform traceBuild that childTid thread is no longer valid. */
        traceBuilder.deleteTid(childTidReal);
    }
private:
    const TsanTraceBuilder<T>& traceBuilder;
    const CTFVarInt& pcVar;
    const CTFVarInt& childTidVar;
};


template<class T>
void TsanTraceBuilder<T>::setupEventBuilders(void)
{
    const CTFTypeEnum* eventTypeEnum = eventTypeVar.getType();
    int nValues = eventTypeEnum->getNValues();
    
    eventBuilders.reserve(nValues);
    
    for(int i = 0; i < nValues; i++)
    {
        const std::string& eventType = eventTypeEnum->valueToStr(i);

        TsanEventBuilder* eventBuilder;
        if(eventType == "fentry")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "fexit")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "fcpre")
            eventBuilder = new TsanEventBuilderFunctionCallPre<T>(*this);
        else if(eventType == "fcpost")
            eventBuilder = new TsanEventBuilderFunctionCallPost<T>(*this);
        else if(eventType == "ma")
            eventBuilder = new TsanEventBuilderMA<T>(*this);
        else if(eventType == "lma_update")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "lma_read")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "lma_write")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "ioma")
            eventBuilder = new TsanEventBuilderIOMA<T>(*this);
        else if(eventType == "mwb")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "mrb")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "mfb")
            eventBuilder = new TsanEventBuilderIgnore();
        else if(eventType == "alloc")
            eventBuilder = new TsanEventBuilderAlloc<T>(*this);
        else if(eventType == "free")
            eventBuilder = new TsanEventBuilderFree<T>(*this);
        else if(eventType == "lock")
            eventBuilder = new TsanEventBuilderLock<T>(*this);
        else if(eventType == "unlock")
            eventBuilder = new TsanEventBuilderUnlock<T>(*this);
        else if(eventType == "rlock")
            eventBuilder = new TsanEventBuilderRLock<T>(*this);
        else if(eventType == "runlock")
            eventBuilder = new TsanEventBuilderRUnlock<T>(*this);
        else if(eventType == "signal")
            eventBuilder = new TsanEventBuilderSignal<T>(*this);
        else if(eventType == "wait")
            eventBuilder = new TsanEventBuilderWait<T>(*this);
        else if(eventType == "tcreate_before")
            eventBuilder = new TsanEventBuilderTCreateBefore<T>(*this);
        else if(eventType == "tcreate_after")
            eventBuilder = new TsanEventBuilderTCreateAfter<T>(*this);
        else if(eventType == "tjoin")
            eventBuilder = new TsanEventBuilderTJoin<T>(*this);
        else
            eventBuilder = new TsanEventBuilderUnknown<T>(*this);
        
        eventBuilders.push_back(eventBuilder);
    }
}



int main(int argc, char** argv)
{
    if(argc != 2)
    {
        std::cerr << "Usage: kedr_simple_converter <directory-with-trace>";
        return -1;
    }
    
    KEDRTraceReader traceReader(argv[1]);
    
    const std::string* pointer_bits = traceReader.findParameter(
        "trace.pointer_bits");
    if(pointer_bits == NULL)
    {
        std::cerr << "Trace should have parameter 'trace.pointer_bits' "
            "defined, but it haven't\n";
        return 1;
    }
    else if(*pointer_bits == "32")
    {
        TsanTraceBuilder<uint32_t> traceBuilder(traceReader);
        traceBuilder.build(std::cout);
    }
    else if(*pointer_bits == "64")
    {
        TsanTraceBuilder<uint32_t> traceBuilder(traceReader);
        traceBuilder.build(std::cout);
    }
    else
    {
        std::cerr << "Unknown value of 'trace.pointer_bits' parameter: "
            << *pointer_bits << "\n";
        return 1;
    }
}