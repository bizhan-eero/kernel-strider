/* CTF 1.8 */

typedef integer {
    signed = false;
    byte_order = network;
    size = 32;
    align = 32;
} __be32;

typedef integer {
    signed = false;
    byte_order = network;
    size = 16;
    align = 16;
} __be16;

typedef integer {
    signed = false;
    byte_order = network;
    size = 8;
    align = 8;
} __u8;

trace {
    major = 1;
    minor = 8;
    uuid = @CTF_UUID_STR@;
    machine_type = @CTF_MACHINE_TYPE@;
    pointer_bits = @CTF_POINTER_BITS_DECLARATION@;
    byte_order = be;
    packet.header := struct {
        __be32 magic;
        __u8 uuid[16];
        __be32 stream_id;
    };
};

typedef integer {
    signed = false;
    byte_order = network;
    size = 64;
    align = 32;
} timestamp_nt;

typedef integer {
    signed = false;
    byte_order = network;
    size = @CTF_POINTER_BITS@;
    align = @CTF_POINTER_BITS@;
} __be_tid;

typedef integer {
    signed = false;
    byte_order = network;
    size = @CTF_POINTER_BITS@;
    align = @CTF_POINTER_BITS@;
} __be_addr;

typedef integer {
    signed = false;
    byte_order = network;
    size = @CTF_POINTER_BITS@;
    align = @CTF_POINTER_BITS@;
} __be_size;



enum event_type : __u8 {
    /* 
     * Event contains array of information about consequent
     * memory accesses.
     */
    execution_event_type_ma,
    /* Event contains information about one locked memory access */
    execution_event_type_lma,
    /* 
     * Event contains information about one memory barrier
     * (read, write, full).
     */
    execution_event_type_mrb,
    execution_event_type_mwb,
    execution_event_type_mfb,
    /* 
     * Event contains information about one memory management operation
     * (alloc/free).
     */
    execution_event_type_alloc,
    execution_event_type_free,
    /* 
     * Event contains information about one lock operation
     * (lock/unlock or its read variants).
     */
    execution_event_type_lock,
    execution_event_type_unlock,
    
    execution_event_type_rlock,
    execution_event_type_runlock,
    /* Event contains information about one signal/wait operation */
    execution_event_type_signal,
    execution_event_type_wait,
    /* Event contains information about thread create/join operation */
    execution_event_type_tcreate,
    execution_event_type_tjoin,
    /* Event contains information about function entry/exit */
    execution_event_type_fentry,
    execution_event_type_fexit,
};


stream {
    id = stream_id;
    event.header := struct {
        __be32 id;
    };
    event.context := struct {
        /* Timestamp of the event */
        timestamp_nt timestamp;
        /* Thread id of the event */
        __be_tid tid;
        /* Type of the event */
        enum event_type type;
        /* Additional type-depended info */
        variant <type> {
            struct {
                __u8 n_subevents;
            } execution_event_type_ma;
            struct {
                __u8 type;
            } execution_event_type_lock;
            /* For other types additional info is empty */
        } add_info;
    };
    packet.context = struct {
        /* Timestamp of the first event in the packet */
        timestamp_nt timestamp_begin;
        /* Timestamp of the last event in the packet */
        timestamp_nt timestamp_end;
        /* Packet count inside stream */
        __be32 stream_packet_count;
        __be16 content_size;/* Size of packet in bits*/
        __be16 packet_size;/* Size of packet in bits, including padding */
    };
};


/******************** Events per-type data ****************************/
/* One element of packed event */
struct execution_event_ma_payload_elem
{
    /* Program counter of the instruction*/
    __be_addr pc;
    /* Access address */
    __be_addr addr;
    /* Access size */
    __be_size size;
    /* Type of access */
    __u8 access_type;
};

struct execution_event_lma_payload
{
    /* Program counter of the instruction*/
    __be_addr pc;
    /* Access address */
    __be_addr addr;
    /* Access size */
    __be_size size;
};

struct execution_event_mb_payload
{
    /* Program counter of the instruction*/
    __be_addr pc;
};

struct execution_event_alloc_payload
{
    /* Program counter of the instruction(normally, call <*alloc>)*/
    __be_addr pc;
    /* Access size */
    __be_size size;
    /* Pointer returned from operation */
    __be_addr pointer;
};

struct execution_event_free_payload
{
    /* Program counter of the instruction(normally, call <*free>)*/
    __be_addr pc;
    /* Pointer for free */
    __be_addr pointer;
};

/* Same structure for lock and unlock events */
struct execution_event_lock_payload
{
    /* Program counter of the instruction(normally, call <*(un)lock*>)*/
    __be_addr pc;
    /* Address of lock object */
    __be_addr object;
};


/* Same structure for signal and wait events */
struct execution_event_sw_payload
{
    /* Program counter of the instruction(normally, call <*>) */
    __be_addr pc;
    /* Address of wait object */
    __be_addr object;
};

/* Same structure for thread create and join events */
struct execution_event_tcj_payload
{
    /* Program counter of the instruction(normally, call <*>) */
    __be_addr pc;
    /* Created or joined thread */
    __be_tid child_tid;
};

/* Same structure for function entry and exit */
struct execution_event_fee_payload
{
    /* Function address */
    __be_addr func;
};

event {
    stream_id = stream_id;
    context := struct {};
    fields := variant <stream.event.context.type> {
        struct {
            struct execution_event_ma_payload_elem [stream.event.context.add_info.execution_event_type_ma.n_subevents]
        } execution_event_type_ma;
        
        struct execution_event_lma_payload execution_event_type_lma;
        
        struct execution_event_mb_payload execution_event_type_mrb;
        struct execution_event_mb_payload execution_event_type_mwb;
        struct execution_event_mb_payload execution_event_type_mfb;
        
        struct execution_event_alloc_payload execution_event_type_alloc;
        struct execution_event_free_payload execution_event_type_free;
        
        struct execution_event_lock_payload execution_event_type_lock;
        struct execution_event_lock_payload execution_event_type_unlock;
        struct execution_event_lock_payload execution_event_type_rlock;
        struct execution_event_lock_payload execution_event_type_runlock;
        
        struct execution_event_sw_payload execution_event_type_signal;
        struct execution_event_sw_payload execution_event_type_wait;
        
        struct execution_event_tcj_payload execution_event_type_tcreate;
        struct execution_event_tcj_payload execution_event_type_tjoin;
        
        struct execution_event_fee_payload execution_event_type_fentry;
        struct execution_event_fee_payload execution_event_type_fexit;
    };
}