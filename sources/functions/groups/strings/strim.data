[group]
	# Name of the target function
	function.name = strim
	
	code.pre =>>
		/* The length of the string may change, so we save it 
		 * here for use in the post-handler. */
		unsigned long str = KEDR_LS_ARG1(ls);
		ls->data = (unsigned long)strlen((const char *)str);
	<<
	
	code.post =>>
		void *data = NULL;
		unsigned long str = KEDR_LS_ARG1(ls);
		unsigned long ret  = KEDR_LS_RET_VAL(ls);
		unsigned long len;
		
		len = ls->data;
		
		/* strim() reads the whole string at least once
		 * (when determining its length). If the string is
		 * not empty, strim() writes 0 to the position occupied 
		 * by the first of the trailing whitespace chars (or by
		 * the terminating null if there are no trailing 
		 * whitespace chars). */
		if (len == 0) {
			if (eh->begin_memory_events != NULL)
				eh->begin_memory_events(eh, ls->tid, 1,
					&data);
			
			if (eh->on_memory_event != NULL) {
				eh->on_memory_event(eh, ls->tid, info->pc, 
					str, 1, KEDR_ET_MREAD, data);
			}

			if (eh->end_memory_events != NULL)
				eh->end_memory_events(eh, ls->tid, data);
		}
		else { /* A non-empty string */
			unsigned long pos = 
				(unsigned long)strlen((const char *)ret);
			if (eh->begin_memory_events != NULL)
				eh->begin_memory_events(eh, ls->tid, 2,
					&data);
			
			if (eh->on_memory_event != NULL) {
				eh->on_memory_event(eh, ls->tid, info->pc, 
					str, len + 1, KEDR_ET_MREAD, data);
				eh->on_memory_event(eh, ls->tid, info->pc, 
					ret + pos, 1, KEDR_ET_MWRITE, data);
			}
			
			if (eh->end_memory_events != NULL)
				eh->end_memory_events(eh, ls->tid, data);
		}
	<<
#######################################################################
