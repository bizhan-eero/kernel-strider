[group]
	# Name of the target function
	function.name = strsep

	# Lookup the address of the function via kallsyms because the
	# compiler may not allow using &<name>. The actual value of
	# this parameter does not matter as long as it is not empty.
	function.lookup = yes
	
	# A convenience function. 
	header_aux =>>
static void
report_events_strsep(struct kedr_local_storage *ls)
{
	struct kedr_call_info *info = (struct kedr_call_info *)(ls->info);
	void *data = NULL;
	char **pstr = (char **)KEDR_LS_ARG1(ls);
	const char *seps = (const char *)KEDR_LS_ARG2(ls);
	char *sbegin = NULL;
	char *end = NULL;
	unsigned long size;
	unsigned long sep_len;
	
	/* First, strsep() reads the pointer the first argument
	 * points to. */
	kedr_eh_on_single_memory_event(ls->tid, info->pc, 
		(unsigned long)pstr, 
		(unsigned long)sizeof(char *), 
		KEDR_ET_MREAD);
	
	sbegin = *pstr;
	if (sbegin == NULL)
		goto out;
	
	sep_len = (unsigned long)strlen(seps);
	if (sep_len == 0)
		goto out;
	
	/* Report reading of the whole 'seps' string, including
	 * the terminating 0. */
	kedr_eh_on_single_memory_event(ls->tid, info->pc, 
		(unsigned long)seps, sep_len + 1, KEDR_ET_MREAD);
	
	end = strpbrk(sbegin, seps);
	if (end == NULL) {
		/* The whole 'sbegin' will be read; NULL will be
		 * written to *pstr. */
		size = (unsigned long)strlen(sbegin) + 1;
		kedr_eh_begin_memory_events(ls->tid, 2, &data);
		kedr_eh_on_memory_event(ls->tid, info->pc, 
			(unsigned long)sbegin, size,
			KEDR_ET_MREAD, data);
		kedr_eh_on_memory_event(ls->tid, info->pc, 
			(unsigned long)pstr, 
			(unsigned long)sizeof(char *),
			KEDR_ET_MWRITE, data);
		kedr_eh_end_memory_events(ls->tid, data);
	}
	else {
		/* The first 'size' bytes of 'sbegin' will be read;
		 * '\0' will be written to *end; end+1 will be 
		 * written to *pstr. */
		size = (unsigned long)(end - sbegin) + 1;
		kedr_eh_begin_memory_events(ls->tid, 3, &data);
		kedr_eh_on_memory_event(ls->tid, info->pc, 
			(unsigned long)sbegin, size,
			KEDR_ET_MREAD, data);
		kedr_eh_on_memory_event(ls->tid, info->pc, 
			(unsigned long)end, 1,
			KEDR_ET_MWRITE, data);
		kedr_eh_on_memory_event(ls->tid, info->pc, 
			(unsigned long)pstr, 
			(unsigned long)sizeof(char *),
			KEDR_ET_MWRITE, data);
		kedr_eh_end_memory_events(ls->tid, data);
	}
out:
	return;
}	
	<<
	
	# For convenience, we report the events from strsep() in the
	# pre-handler here. The code is based on the implementation
	# of strsep() from lib/strings.c in the kernel sources. */
	code.pre =>>
		report_events_strsep(ls);
	<<
#######################################################################
